<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>聪少</title>
  
  
  <link href="http://cong.im/atom.xml" rel="self"/>
  
  <link href="http://cong.im/"/>
  <updated>2021-01-11T07:40:02.568Z</updated>
  <id>http://cong.im/</id>
  
  <author>
    <name>聪少</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux内存管理</title>
    <link href="http://cong.im/2021/01/11/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://cong.im/2021/01/11/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-01-11T07:39:49.000Z</published>
    <updated>2021-01-11T07:40:02.568Z</updated>
    
    
    
    
    <category term="linux" scheme="http://cong.im/categories/linux/"/>
    
    
    <category term="linux" scheme="http://cong.im/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>跨进程复制socket</title>
    <link href="http://cong.im/2020/12/15/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E5%A4%8D%E5%88%B6socket/"/>
    <id>http://cong.im/2020/12/15/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E5%A4%8D%E5%88%B6socket/</id>
    <published>2020-12-15T03:15:04.000Z</published>
    <updated>2020-12-22T07:47:41.071Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;linux为什么能跨进程传递socket文件描述符&quot;&gt;&lt;a href=&quot;#linux为什么能跨进程传递socket文件描述符&quot; class=&quot;headerlink&quot; title=&quot;linux为什么能跨进程传递socket文件描述符&quot;&gt;&lt;/a&gt;linux为什么能跨进程传递socket文件描述符&lt;/h1&gt;&lt;p&gt;在Linux中一切皆文件，文件系统是进程所共有的。而socket本身是在网络文件系统空间申请的，socket也是文件一种，所以在同一台主机下，socket是可以跨进程传递的。&lt;br&gt;下面仔细跟踪一下socket创建的过程（3.10内核）。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://cong.im/categories/linux/"/>
    
    
    <category term="linux" scheme="http://cong.im/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>io知识</title>
    <link href="http://cong.im/2020/12/09/io%E5%88%86%E6%9E%90/"/>
    <id>http://cong.im/2020/12/09/io%E5%88%86%E6%9E%90/</id>
    <published>2020-12-09T08:28:28.000Z</published>
    <updated>2020-12-25T02:25:14.790Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Linux文件系统&quot;&gt;&lt;a href=&quot;#Linux文件系统&quot; class=&quot;headerlink&quot; title=&quot;Linux文件系统&quot;&gt;&lt;/a&gt;Linux文件系统&lt;/h1&gt;&lt;p&gt;文件系统本身是对存储设备上的文件进行组织管理的机制。组织方式不同就形成不同的文件系统。&lt;br&gt;在Linux中一切皆为文件，为了方便管理Linux文件系统为每个文件都分配两个数据结构，索引节点、和目录项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引节点 用来记录文件的元数据如inode编号、文件大小、访问权限等，inode跟文件内容一样都会被持久化到磁盘中&lt;/li&gt;
&lt;li&gt;目录项 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="linux" scheme="http://cong.im/categories/linux/"/>
    
    
    <category term="linux" scheme="http://cong.im/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>cpu性能分析</title>
    <link href="http://cong.im/2020/12/08/cpu%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://cong.im/2020/12/08/cpu%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</id>
    <published>2020-12-08T12:21:15.000Z</published>
    <updated>2020-12-22T07:47:41.070Z</updated>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;面对问题束手无策&lt;/li&gt;
&lt;li&gt;面对“系统”、“底层”发怵&lt;/li&gt;
&lt;li&gt;遇到根源复杂的性能问题既不懂怎么去分析，也不能抽丝剥茧的找到瓶颈&lt;/li&gt;
&lt;li&gt;随遇而安，认为遇到问题上网查就行了。有可能解决问题，但是懒得研究为何有效</summary>
    
    
    
    <category term="linux" scheme="http://cong.im/categories/linux/"/>
    
    
    <category term="linux" scheme="http://cong.im/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>进程小知识</title>
    <link href="http://cong.im/2020/07/20/%E8%BF%9B%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>http://cong.im/2020/07/20/%E8%BF%9B%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2020-07-20T05:08:55.000Z</published>
    <updated>2020-12-22T07:47:41.071Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h3&gt;&lt;p&gt;进程就是应用程序启动的实例。进程拥有代码和打开的文件资源、数据资源、独立的内存空间&lt;/p&gt;
&lt;h4 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h4&gt;&lt;p&gt;线程从属进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的自线程，线程拥有自己的栈空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对操作系统来说线程是最小的执行单元，而进程是最小的资源管理单元。&lt;/li&gt;
&lt;li&gt;无论线程还是进程都是操作系统管理的 &lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="linux" scheme="http://cong.im/categories/linux/"/>
    
    
    <category term="linux" scheme="http://cong.im/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>mysql小知识</title>
    <link href="http://cong.im/2020/07/20/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>http://cong.im/2020/07/20/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2020-07-20T02:19:25.000Z</published>
    <updated>2020-12-22T07:47:41.071Z</updated>
    
    
    <summary type="html">&lt;h4 id=&quot;事务的基本要素&quot;&gt;&lt;a href=&quot;#事务的基本要素&quot; class=&quot;headerlink&quot; title=&quot;事务的基本要素&quot;&gt;&lt;/a&gt;事务的基本要素&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原子性&lt;br&gt;  事务开始后的所有操作要么做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错会回滚到事务开始的状态。所有的操作就像没有发生过一样。也就是说一个事务是一个不可分割的整体。(undo log实现)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一致性&lt;br&gt;  事务开始前和结束后，数据库的完整约束没有被破坏。如A向B赚钱，不可能A扣了钱，B却没收到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离性&lt;br&gt;  统一时间只允许一个事务请求同一数据，不同事务之间彼此没有任何干扰。比如A正从银行开中取钱，在A取钱的过程中，B不能向这张卡转账。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持久性&lt;br&gt;事务一旦提交，其更改是永久性的，即使数据库系统崩溃也能恢复。（redo log实现）&lt;/p&gt;</summary>
    
    
    
    <category term="db" scheme="http://cong.im/categories/db/"/>
    
    
    <category term="db" scheme="http://cong.im/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>hbase安装</title>
    <link href="http://cong.im/2020/07/15/hbase%E5%AE%89%E8%A3%85/"/>
    <id>http://cong.im/2020/07/15/hbase%E5%AE%89%E8%A3%85/</id>
    <published>2020-07-15T02:31:39.000Z</published>
    <updated>2020-12-22T07:47:41.071Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;hadoop-2.8.0.tar.gz&lt;/li&gt;
&lt;li&gt;hbase-1.3.1-bin.tar.gz&lt;/li&gt;
&lt;li&gt;zookeeper-3.4.9.tar.gz&lt;/li&gt;
&lt;li&gt;CentOS Linux release 7.6.1810 (Core) * 3&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="db" scheme="http://cong.im/categories/db/"/>
    
    
    <category term="db" scheme="http://cong.im/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>centos7安装cassandra</title>
    <link href="http://cong.im/2020/07/15/centos7%E5%AE%89%E8%A3%85cassandra/"/>
    <id>http://cong.im/2020/07/15/centos7%E5%AE%89%E8%A3%85cassandra/</id>
    <published>2020-07-15T02:26:25.000Z</published>
    <updated>2020-12-22T07:47:41.070Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在开发监控系统，后台存储使用了cassandra,安装的时候留个档！&lt;/p&gt;
&lt;h3 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 操作系统&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3*CentOS Linux release 7.6.1810 (Core)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; java版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[admin@db-apmDB-1 ~]$ java -version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java version &amp;quot;1.8.0_152&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Java(TM) SE Runtime Environment (build 1.8.0_152-b16)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 安装包&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apache-cassandra-3.11.4-bin.tar.gz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="db" scheme="http://cong.im/categories/db/"/>
    
    
    <category term="db" scheme="http://cong.im/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>如何提升内存分配的效率</title>
    <link href="http://cong.im/2020/06/24/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%95%88%E7%8E%87/"/>
    <id>http://cong.im/2020/06/24/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%95%88%E7%8E%87/</id>
    <published>2020-06-24T06:48:16.000Z</published>
    <updated>2020-12-22T07:47:41.071Z</updated>
    
    
    <summary type="html">&lt;p&gt;谈这个底层话题略显唐突，因为大部分开发者并不关心底层，内存分配依赖于各种工具提供的方法，底层具体怎么做的并不关心。如果你也这么想，那么在JVM配置最大内存为8G，并发近百个线程的情况下观察到Java进程占用内存远远超过8G分配内存。如果不了解底层你可能永远不知道为什么会这样。&lt;/p&gt;
&lt;p&gt;大部分高级语言或多或少都与C语言有一定关系，如Java，申请内存必须经过C库，C库为了加快内存分配速度，通过预分配更大的空间作为内存池。这样预先分配的6GB的C库内存池就与JVM中预先分配的8G内存池叠加在一起，造成Java进程内存占用超出预期。&lt;/p&gt;
&lt;h3 id=&quot;了解内存池的好处&quot;&gt;&lt;a href=&quot;#了解内存池的好处&quot; class=&quot;headerlink&quot; title=&quot;了解内存池的好处&quot;&gt;&lt;/a&gt;了解内存池的好处&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;避免写程序时内存占用过大导致服务整体性能下降或者OOM的情况&lt;/li&gt;
&lt;li&gt;加快内存分配速度（分布式环境下繁忙的多线程服务获取内存的时间可能会上升几十倍）&lt;/li&gt;
&lt;li&gt;优化内存池技术应用在分布式环境可大大提升性能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何提升内存分配速度&quot;&gt;&lt;a href=&quot;#如何提升内存分配速度&quot; class=&quot;headerlink&quot; title=&quot;如何提升内存分配速度&quot;&gt;&lt;/a&gt;如何提升内存分配速度&lt;/h2&gt;</summary>
    
    
    
    <category term="linux" scheme="http://cong.im/categories/linux/"/>
    
    
    <category term="linux" scheme="http://cong.im/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>网关简介</title>
    <link href="http://cong.im/2020/05/21/apigateway/"/>
    <id>http://cong.im/2020/05/21/apigateway/</id>
    <published>2020-05-21T05:33:58.000Z</published>
    <updated>2020-12-22T07:47:41.070Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;网关作用&quot;&gt;&lt;a href=&quot;#网关作用&quot; class=&quot;headerlink&quot; title=&quot;网关作用&quot;&gt;&lt;/a&gt;网关作用&lt;/h3&gt;&lt;p&gt;网关分为两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入口网关&lt;br&gt;入口网关将一些服务共有的功能整合在一起，独立部署为单独的一层，用来解决一些服务治理的问题。可以把网关看作系统边界，它可以对出入系统的流量进行统一的管控。网关提供客户端一个统一的接入地址，API网关可以将用户的请求动态路由到不同的业务服务上，并且做一些必要的协议转换工作。在服务系统中对外暴露的协议可能不同，如http服务，rpc服务等等，甚至有些历史遗留的服务。API网关可以很好的对客户端屏蔽这些服务的地址以及协议细节，给客户端接入带来极大的便捷。&lt;br&gt;在API网关中可以加入一些服务治理策略，如服务熔断、降级、流量控制、分流等。对于客户端等认证、鉴权也可以放在API网关中。另外还可以配合黑白名单，如设备ID、用户ID等维度策略。在网关中还可以很方便的做一些统计工作，如访问订单服务、商品服务等等。&lt;/li&gt;
&lt;li&gt;出口网关&lt;br&gt;出口网关，在实际的系统开发过程中，会依赖很多外部的三方服务，如三方账号登录、三方支付服务等。所以开发者可以在自身服务和三方服务之间部署出口网关，在出口网关中对外调用外部的API做统一的认证、授权、审计和权限访问。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://cong.im/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="http://cong.im/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
