<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网关简介</title>
    <url>/2020/05/21/apigateway/</url>
    <content><![CDATA[<h3 id="网关作用"><a href="#网关作用" class="headerlink" title="网关作用"></a>网关作用</h3><p>网关分为两类</p>
<ul>
<li>入口网关<br>入口网关将一些服务共有的功能整合在一起，独立部署为单独的一层，用来解决一些服务治理的问题。可以把网关看作系统边界，它可以对出入系统的流量进行统一的管控。网关提供客户端一个统一的接入地址，API网关可以将用户的请求动态路由到不同的业务服务上，并且做一些必要的协议转换工作。在服务系统中对外暴露的协议可能不同，如http服务，rpc服务等等，甚至有些历史遗留的服务。API网关可以很好的对客户端屏蔽这些服务的地址以及协议细节，给客户端接入带来极大的便捷。<br>在API网关中可以加入一些服务治理策略，如服务熔断、降级、流量控制、分流等。对于客户端等认证、鉴权也可以放在API网关中。另外还可以配合黑白名单，如设备ID、用户ID等维度策略。在网关中还可以很方便的做一些统计工作，如访问订单服务、商品服务等等。</li>
<li>出口网关<br>出口网关，在实际的系统开发过程中，会依赖很多外部的三方服务，如三方账号登录、三方支付服务等。所以开发者可以在自身服务和三方服务之间部署出口网关，在出口网关中对外调用外部的API做统一的认证、授权、审计和权限访问。</li>
</ul>
<a id="more"></a>

<h3 id="实现注意细节"><a href="#实现注意细节" class="headerlink" title="实现注意细节"></a>实现注意细节</h3><ul>
<li>性能<br>  API网关承接所有从客户端的所有流量，假如业务处理需要10ms，在API网关处理需要1ms，那么相当于每个API的响应时间需要增加10%，无疑在对性能影响是重大的。提升API网关的性能很重要的一部分在于I/O模型。Netfix开源的API网关Zuul中采用I/O多路复用的模型处理接入的I/O请求，并且使用非阻塞的调用方式。除此之外，API网关中执行动作有些是可以预先定义好的，如黑白名单、接口动态路由等等。API网关在设计的时候需要注意拓展性，方便开发者随时在网关上增加一些逻辑或者下掉一些逻辑。<br>一般来说，可以把每一个操作定义为一个filter过滤器，然后使用责任链模式将这些过滤器串起来。责任链可以动态的组织这些过滤器，解偶过滤器之间的关系，无轮增加还是减少都对其他过滤器无任何影响。（过滤器通常分为三种过滤器：1. 路由前过滤器 2. 路由过滤器 3. 路由后过滤器）</li>
</ul>
<p><img src="/images/apigateway/WechatIMG8.png" alt="WechatIMG8"></p>
<ul>
<li>线程隔离/保护<br>  为了提升网关的并行处理能力，一般使用线程池来执行请求。当在后端服务响应缓慢的时候，线程池中线程就会被后端的缓慢服务消耗殆尽，那么其他服务的请求就会受到影响，所以我们要针对不同的服务做线程隔离或者保护。<br>  以下两种方法：<ul>
<li>如果后端的服务拆分的不多，可以针对不同的服务采用不同的线程池，这样发生故障的服务就不会影响其他正常的服务了</li>
<li>线程池内部可以针对不同服务甚至不同的接口做线程保护。如线程池的最大线程是1000，那么可以给每个服务设置一个最多的使用配额。（在golang中可以适当的控制携程数量，来达到控制线程数的相同目的）</li>
</ul>
</li>
</ul>
<h3 id="如何引用API网关"><a href="#如何引用API网关" class="headerlink" title="如何引用API网关"></a>如何引用API网关</h3><p>用电商应用举个例子，在服务层和客户端之间有一层Web层，这个Web层主要做两个方面的事情：</p>
<ol>
<li><p><strong><em>对服务层接口数据的聚合</em></strong>。如商品详情页的接口可能聚合到服务层总，获取商品信息、用户信息、店铺信息以及用户评论等多个服务的接口数据。 </p>
</li>
<li><p><strong><em>Web层可能需要将Http请求转换成RPC请求，且对某些请求添加黑名单功能等</em></strong>。因此我们在做改造的时候可以先将API网关先从Web层中独立出来，将协议转换、限流、黑明单等功能搬到API网关中来处理，形成独立的**<em>入口网关**</em>。</p>
</li>
</ol>
<p>针对服务接口数据聚合的操作一般两种解决思路是：</p>
<ul>
<li><p>独立一组网关专门做聚合、超时控制方面的事情，前一种网关称作流量网关，后一种称作业务网关</p>
</li>
<li><p>抽取独立的服务层，做门做接口聚合操作。这样服务层就大概分为原子服务层和聚合服务层。</p>
</li>
</ul>
<p>接口数据聚合是业务操作，与其放在通用网关来实现不如放在更贴近业务的服务层来实现</p>
<p><img src="/images/apigateway/WechatIMG7.png" alt="WechatIMG7"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装cassandra</title>
    <url>/2020/07/15/centos7%E5%AE%89%E8%A3%85cassandra/</url>
    <content><![CDATA[<p>最近在开发监控系统，后台存储使用了cassandra,安装的时候留个档！</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 操作系统</span></span><br><span class="line">3*CentOS Linux release 7.6.1810 (Core)</span><br><span class="line"><span class="meta">#</span><span class="bash"> java版本</span></span><br><span class="line">[admin@db-apmDB-1 ~]$ java -version</span><br><span class="line">java version &quot;1.8.0_152&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_152-b16)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装包</span></span><br><span class="line">apache-cassandra-3.11.4-bin.tar.gz</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>apache-cassandra-3.11.4-bin.tar.gz <a href="https://cassandra.apache.org/">下载地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxf  apache-cassandra-3.11.4-bin.tar.gz -C /httx/run/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名</span></span><br><span class="line">mv apache-cassandra-3.11.4 cassandra-3.11.4</span><br></pre></td></tr></table></figure>

<h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开环境变量文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加环境变量</span></span><br><span class="line">export CASSANDRA_HOME=/httx/run/cassandra-3.11.4</span><br><span class="line">export PATH=$PATH:$CASSANDRA_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 立刻生效</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="创建数据目录"><a href="#创建数据目录" class="headerlink" title="创建数据目录"></a>创建数据目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 数据目录</span></span><br><span class="line">mkdir -p /httx/run/cassandra_data/data1</span><br><span class="line">mkdir -p /httx/run/cassandra_data/data2</span><br><span class="line">mkdir -p /httx/run/cassandra_data/data3</span><br><span class="line">mkdir -p /httx/run/cassandra_data/data4</span><br><span class="line">mkdir -p /httx/run/cassandra_data/data5</span><br><span class="line"><span class="meta">#</span><span class="bash"> commitlog目录</span></span><br><span class="line">mkdir -p /httx/run/cassandra_data/data6</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $CASSANDRA_HOME/conf </span><br><span class="line">vim cassandra.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置集群名</span><br><span class="line"># The name of the cluster. This is mainly used to prevent machines in</span><br><span class="line"># one logical cluster from joining another.</span><br><span class="line">cluster_name: &#39;APM Cluster&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置集群种子节点IP，如果多个用逗号分隔</span><br><span class="line"># seeds is actually a comma-delimited list of addresses.</span><br><span class="line">          # Ex: &quot;&lt;ip1&gt;,&lt;ip2&gt;,&lt;ip3&gt;&quot;</span><br><span class="line">          - seeds: &quot;你的机器IP1,你的机器IP2,你的机器IP3&quot;</span><br><span class="line"></span><br><span class="line"># 设置监听地址(本机的IP)，是为了其他节点能与节点进行通信(默认是 localhost)，每台机器填自己机器的IP</span><br><span class="line"># address associated with the hostname (it might not be).</span><br><span class="line">#</span><br><span class="line"># Setting listen_address to 0.0.0.0 is always wrong.</span><br><span class="line">#</span><br><span class="line">listen_address: 你本机IP</span><br><span class="line"></span><br><span class="line"># 开启 thrift rpc 服务(默认是 false)</span><br><span class="line"># Whether to start the thrift rpc server.</span><br><span class="line">start_rpc: true</span><br><span class="line"></span><br><span class="line"># 设置rpc的地址(默认是 localhost)</span><br><span class="line"># For security reasons, you should not expose this port to the internet.  Firewall it if needed.</span><br><span class="line">rpc_address: 你本机IP</span><br><span class="line"></span><br><span class="line"># 设置数据文件所在路径(默认是在cassandra目录下的data)</span><br><span class="line"># Directories where Cassandra should store data on disk.  Cassandra</span><br><span class="line"># will spread data evenly across them, subject to the granularity of</span><br><span class="line"># the configured compaction strategy.</span><br><span class="line"># If not set, the default directory is $CASSANDRA_HOME&#x2F;data&#x2F;data.</span><br><span class="line">data_file_directories:</span><br><span class="line">     - &#x2F;httx&#x2F;run&#x2F;cassandra_data&#x2F;data1</span><br><span class="line">     - &#x2F;httx&#x2F;run&#x2F;cassandra_data&#x2F;data2</span><br><span class="line">     - &#x2F;httx&#x2F;run&#x2F;cassandra_data&#x2F;data3</span><br><span class="line">     - &#x2F;httx&#x2F;run&#x2F;cassandra_data&#x2F;data4</span><br><span class="line">     - &#x2F;httx&#x2F;run&#x2F;cassandra_data&#x2F;data5</span><br><span class="line"># 设置commit log目录</span><br><span class="line"># commit log.  when running on magnetic HDD, this should be a</span><br><span class="line"># separate spindle than the data directories.</span><br><span class="line"># If not set, the default directory is $CASSANDRA_HOME&#x2F;data&#x2F;commitlog.</span><br><span class="line">commitlog_directory: &#x2F;httx&#x2F;run&#x2F;cassandra_data&#x2F;data6</span><br></pre></td></tr></table></figure>
<pre><code>因为这两个文件很大，分散集群中磁盘I/O压力，前者是cassandra实际数据存放的目录，后者是数据写入commitlog的文件目录</code></pre>
<p>可以将上面上述修改的配置文件拷贝到其他的机器上，但是一定要修改$CASSANDRA_HOME/conf/cassandra.yaml 中的 listen_address 和 rpc_address 将其设置成自己的IP</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 分别在三台上执行</span></span><br><span class="line">cassandra</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态,现实UN为正常，DN为异常</span></span><br><span class="line">[admin@db-apmDB-1 /httx/run/cassandra-3.11.4/bin]$ nodetool status</span><br><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address      Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  你的ip1  431.18 KiB  256          63.9%             82bb5bf7-504b-44b6-a630-55b6f8ef1b3c  rack1</span><br><span class="line">UN  你的ip2  274.44 KiB  256          68.7%             b82dd539-28bf-4934-91f1-ae48dd25cb57  rack1</span><br><span class="line">UN  你的ip3  245.96 KiB  256          67.3%             a90214dc-4232-47a0-9ca3-b2ea225903cf  rack1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cqlsh</span> </span><br><span class="line">[admin@db-apmDB-1 ~]$ cqlsh 你的IP</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.4 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line"><span class="meta">cqlsh&gt;</span></span><br></pre></td></tr></table></figure>
<p>完成！！！</p>
]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>hbase安装</title>
    <url>/2020/07/15/hbase%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>hadoop-2.8.0.tar.gz</li>
<li>hbase-1.3.1-bin.tar.gz</li>
<li>zookeeper-3.4.9.tar.gz</li>
<li>CentOS Linux release 7.6.1810 (Core) * 3</li>
</ul>
<a id="more"></a>

<h3 id="配置ssh密码免登陆"><a href="#配置ssh密码免登陆" class="headerlink" title="配置ssh密码免登陆"></a>配置ssh密码免登陆</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 产生密钥</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t dsa -P <span class="string">&#x27;&#x27;</span> -f ~/.ssh/id_dsa</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 导入authorized_keys</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 将密钥文件拷贝至所有slave机器</span></span></span><br><span class="line">scp authorized_keys slave1@slave1:~/.ssh/authorized_keys_from_master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 进入slave每一台的.ssh目录，如下操作</span></span></span><br><span class="line">cat authorized_keys_from_master  &gt;&gt;  authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 配置每台主机hosts</span></span></span><br><span class="line">/etc/hosts</span><br><span class="line">masterIP地址 master</span><br><span class="line">slave1地址 slave1</span><br><span class="line">slave1地址 slave2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 最后一步很重要，要在master主机上登录一次slave1和slave2</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 因为第一次登录需要验证密码的，后面则不需要</span></span></span><br></pre></td></tr></table></figure>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 配置文件在hadoop&#x2F;etc&#x2F;hadoop目录下，依次将内容拷贝进去</span><br><span class="line">### core-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;master123:9000&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;io.file.buffer.size&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;131072&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;httx&#x2F;run&#x2F;hadoop&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.proxyuser.aboutyun.hosts&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.proxyuser.aboutyun.groups&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">### hdfs-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.secondary.http-address&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;master:9001&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;httx&#x2F;run&#x2F;hadoop&#x2F;dfs&#x2F;name&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;httx&#x2F;run&#x2F;hadoop&#x2F;dfs&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.webhdfs.enabled&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">### mapred-site.xml </span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.address&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;master:10020&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;master:19888&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### yarn-site.xml</span><br><span class="line">&lt;configuration&gt;  </span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.address&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;master:8032&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;master:8030&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;master:8031&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.admin.address&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;master:8033&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;master:8089&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;  </span><br></pre></td></tr></table></figure>

<pre><code>core-site.xml 、 hdfs-site.xml一定不要忘记拷贝到hbase/conf目录下</code></pre>
<h4 id="配置jdk"><a href="#配置jdk" class="headerlink" title="配置jdk"></a>配置jdk</h4><p>hadoop-env.sh<br>修改JAVA_HOME值（export JAVA_HOME=/usr/jdk1.7） /httx/run/jdk<br>yarn-env.sh<br>修改JAVA_HOME值（export JAVA_HOME=/usr/jdk1.7）</p>
<p>slaves （这个文件里面保存所有slave节点）<br>slave1<br>slave2</p>
<p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 第一步每一台都要执行</span><br><span class="line">hadoop&#x2F;bin&#x2F;hdfs namenode -format  </span><br><span class="line">hadoop&#x2F;sbin&#x2F;start-dfs.sh</span><br><span class="line">hadoop&#x2F;sbin&#x2F;start-yarn.sh</span><br></pre></td></tr></table></figure>

<h3 id="zookeeper-安装启动"><a href="#zookeeper-安装启动" class="headerlink" title="zookeeper 安装启动"></a>zookeeper 安装启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv zoo_sample.cfg zoo.cfg</span><br><span class="line">zoo.cfg  </span><br><span class="line">dataDir=/httx/run/zookeeper/data/data</span><br><span class="line">dataLogDir=/httx/run/zookeeper/data/log</span><br><span class="line">server.1=主机1:2888:3888</span><br><span class="line">server.2=主机2:2888:3888</span><br><span class="line">server.3=主机3:2888:3888</span><br><span class="line"></span><br><span class="line">在data里会放置一个myid文件，里面就一个数字，用来唯一标识这个服务。这个id是很重要的，一定要保证整个集群中唯一</span><br><span class="line">ZooKeeper会根据这个id来取出server.x上的配置。比如当前id为1，则对应着zoo.cfg里的server.1的配置</span><br><span class="line"></span><br><span class="line">/httx/run/zookeeper/data/data  添加 myid  </span><br><span class="line"></span><br><span class="line">分别在三台机器上做</span><br><span class="line"></span><br><span class="line">echo &quot;1&quot; &gt; /httx/run/zookeeper/data/data/myid</span><br><span class="line">echo &quot;2&quot; &gt; /httx/run/zookeeper/data/data/myid</span><br><span class="line">echo &quot;3&quot; &gt; /httx/run/zookeeper/data/data/myid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">每一台启动：cd /httx/run/zookeeper</span><br><span class="line">./bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<h2 id="hbase-安装启动"><a href="#hbase-安装启动" class="headerlink" title="hbase 安装启动"></a>hbase 安装启动</h2><h3 id="hbase-env-sh-配置"><a href="#hbase-env-sh-配置" class="headerlink" title="hbase-env.sh 配置"></a>hbase-env.sh 配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;httx&#x2F;run&#x2F;jdk</span><br><span class="line">export HBASE_MANAGES_ZK&#x3D;false</span><br><span class="line">export HBASE_HEAPSIZE&#x3D;8000</span><br><span class="line">export HBASE_LOG_DIR&#x3D;&#x2F;httx&#x2F;run&#x2F;hbase&#x2F;log</span><br></pre></td></tr></table></figure>

<h3 id="hbase-site-xml-配置"><a href="#hbase-site-xml-配置" class="headerlink" title="hbase-site.xml 配置"></a>hbase-site.xml 配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.rootdir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;master:9000&#x2F;hbase&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.cluster.distributed&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.zookeeper.quorum&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;zk地址1:2181,zk地址2:2181,zk地址3:2181&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.support.append&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;zookeeper.session.timeout.ms&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;400000&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.hregion.max.filesize&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;64424509440&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置-regionservers"><a href="#配置-regionservers" class="headerlink" title="配置 regionservers"></a>配置 regionservers</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>

<h3 id="启动hbase"><a href="#启动hbase" class="headerlink" title="启动hbase"></a>启动hbase</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;start-hbase.sh</span><br><span class="line">.&#x2F;bin&#x2F;hbase shell</span><br></pre></td></tr></table></figure>

<pre><code>按照上面到流程安装成功了，表也创建成功了，但是在put的时候会报错，找了很多资料发现
仅仅是因为linux（centos）的hosts的问题，是由于默认hosts中的local.localdomain。</code></pre>
<p>将下面/etc/hosts文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"></span><br><span class="line">主机1 db-apmKVStore-1.100.idc.tf56 db-apmKVStore-1</span><br><span class="line">主机1 master</span><br><span class="line">主机2 slave1</span><br><span class="line">主机3 slave2</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span></span><br><span class="line"></span><br><span class="line">主机1 db-apmKVStore-1.100.idc.tf56 db-apmKVStore-1</span><br><span class="line">主机1 master</span><br><span class="line">主机2 slave1</span><br><span class="line">主机3 slave2</span><br></pre></td></tr></table></figure>
<p>将local.localdomain全部去除</p>
<pre><code>在访问hbase的客户端的服务器上记得在/etc/hosts文件中加上，不然会访问不通hbase</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">主机1 master</span><br><span class="line">主机2 slave1</span><br><span class="line">主机3 slave2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提升内存分配的效率</title>
    <url>/2020/06/24/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<p>谈这个底层话题略显唐突，因为大部分开发者并不关心底层，内存分配依赖于各种工具提供的方法，底层具体怎么做的并不关心。如果你也这么想，那么在JVM配置最大内存为8G，并发近百个线程的情况下观察到Java进程占用内存远远超过8G分配内存。如果不了解底层你可能永远不知道为什么会这样。</p>
<p>大部分高级语言或多或少都与C语言有一定关系，如Java，申请内存必须经过C库，C库为了加快内存分配速度，通过预分配更大的空间作为内存池。这样预先分配的6GB的C库内存池就与JVM中预先分配的8G内存池叠加在一起，造成Java进程内存占用超出预期。</p>
<h3 id="了解内存池的好处"><a href="#了解内存池的好处" class="headerlink" title="了解内存池的好处"></a>了解内存池的好处</h3><ul>
<li>避免写程序时内存占用过大导致服务整体性能下降或者OOM的情况</li>
<li>加快内存分配速度（分布式环境下繁忙的多线程服务获取内存的时间可能会上升几十倍）</li>
<li>优化内存池技术应用在分布式环境可大大提升性能</li>
</ul>
<h2 id="如何提升内存分配速度"><a href="#如何提升内存分配速度" class="headerlink" title="如何提升内存分配速度"></a>如何提升内存分配速度</h2><a id="more"></a>)
<h3 id="隐藏的内存池"><a href="#隐藏的内存池" class="headerlink" title="隐藏的内存池"></a>隐藏的内存池</h3><p>在业务代码和系统内核间，往往有两层内存池被忽略，其中C库的内存池尤盛。当代码申请内存时请求首先到达应用内存池，如果内存应用池有足够的内存可以使用，那么就直接返回给业务代码，否则会向底层C库内存池申请。</p>
<p><img src="/images/%E6%8F%90%E9%AB%98%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%95%88%E7%8E%87/WechatIMG9.png" alt="WechatIMG9"></p>
<h3 id="Ptmalloc2"><a href="#Ptmalloc2" class="headerlink" title="Ptmalloc2"></a>Ptmalloc2</h3><h3 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h3><h3 id="如何选择Ptmalloc2和TCMalloc？"><a href="#如何选择Ptmalloc2和TCMalloc？" class="headerlink" title="如何选择Ptmalloc2和TCMalloc？"></a>如何选择Ptmalloc2和TCMalloc？</h3><h3 id="从堆还是栈上分配内存？"><a href="#从堆还是栈上分配内存？" class="headerlink" title="从堆还是栈上分配内存？"></a>从堆还是栈上分配内存？</h3>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu性能分析</title>
    <url>/2020/12/08/cpu%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>面对问题束手无策</li>
<li>面对“系统”、“底层”发怵</li>
<li>遇到根源复杂的性能问题既不懂怎么去分析，也不能抽丝剥茧的找到瓶颈</li>
<li>随遇而安，认为遇到问题上网查就行了。有可能解决问题，但是懒得研究为何有效<a id="more"></a>
<h1 id="性能和性能分析"><a href="#性能和性能分析" class="headerlink" title="性能和性能分析"></a>性能和性能分析</h1>关于性能，我们首先想到的就是<code>高并发</code>、<code>响应快</code>。这两个词对应着性能优化的两个核心指标“吞吐”和“延时”。而这两个指标是<br>从<code>应用负载</code>的角度来考察性能。我们知道，随着应用负载的增加，系统资源的使用也会升高，甚至达到极限。而<code>性能的本质</code>就<br>是系统资源达到瓶颈，无法支撑更多的请求。</li>
</ul>
<p><code>性能分析</code>就是为了找出<code>应用或者系统的瓶颈，并设法去避免或者缓解它们</code><br>，从高更高效的利用系统资源处理更多的请求。这通常包含了以下几个步骤：</p>
<ul>
<li>选择指标评估应用程序和系统的性能</li>
<li>为应用程序和系统设置性能目标</li>
<li>进行性能基准测试</li>
<li>性能分析定位瓶颈</li>
<li>优化系统和应用程序</li>
<li>性能监控和告警</li>
</ul>
<h1 id="理解平均负载"><a href="#理解平均负载" class="headerlink" title="理解平均负载"></a>理解平均负载</h1><p>当发现系统变慢的时候，我们通常做的第一件事就是执行<code>top</code>或者<code>uptime</code>来观察系统负载情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test-monitor-alert-1 ~]# uptime</span><br><span class="line"> 10:26:33 up 26 days, 17:10,  2 users,  load average: 0.02, 0.04, 0.05</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10:26:33                           &#x2F;&#x2F; 当前时间</span><br><span class="line">up 26 days                         &#x2F;&#x2F; 系统运行时间</span><br><span class="line">2 users                            &#x2F;&#x2F; 正在登陆用户</span><br><span class="line">load average: 0.02, 0.04, 0.05     &#x2F;&#x2F; 依次则是过去 1 分钟、5 分钟、15 分钟的平均负载</span><br></pre></td></tr></table></figure>

<p>理解平均负载之前我们先了解以下两种状态</p>
<ul>
<li>可运行状态: 所谓可运行状态的进程，是指正在使用CPU或者正在等待CPU的进程，也就是我们常用ps命令看到的，处于R状态（Running 或 Runnable）的进程。</li>
<li>不可中断状态: 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的I/O响应，也就是我们在ps命令中看到的D状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。</li>
</ul>
<p>平均负载实际上就是平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。这个“指数衰减平均”的详细含义不用计较，这只是系统的一种更快速的计算方式，你把它直接当成活跃进程数的平均值也没问题。</p>
<p>举个例子，当平均负载为2时意味着什么：</p>
<ul>
<li>在只有2个CPU的系统上，意味着所有CPU刚好被完全占用</li>
<li>在只有4个CPU的系统上，意味着CPU有50%的空闲</li>
<li>在只有1个CPU的系统上，意味着有一半的进程竞争不到CPU</li>
</ul>
<h2 id="平均负载多少合理"><a href="#平均负载多少合理" class="headerlink" title="平均负载多少合理"></a>平均负载多少合理</h2><p>回答这个问题之前我们需要知道系统有几个CPU，可以通过top或者从文件/proc/cpuinfi中读取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test-monitor-alert-1 ~]# grep &#x27;model name&#x27; /proc/cpuinfo | wc -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>有了CPU个数就可以判断出当平均负载比CPU个数还打当时候，系统已经出现了过载。那么平均负载的三个数值理解如下：</p>
<ul>
<li>如果1、5、15的三个数值基本相同，或者相差不大，那么说明系统负载很平稳</li>
<li>如果1的值远小于15分钟的值，说明系统最近1分钟负载在减少，过去15分钟内负载很高，反之同理</li>
</ul>
<p>平均负载高于CPU数量70%当时候就需要排查负载高的原因</p>
<h2 id="平均负载与CPU使用率"><a href="#平均负载与CPU使用率" class="headerlink" title="平均负载与CPU使用率"></a>平均负载与CPU使用率</h2><p>在实际工作中我们经常把平均负载与CPU使用率混淆，平均负载是指单位时间内处于可运行状态和不可中断状态的进程数。所以他不仅包括了正在使用的CPU进程，还<br>包括等待CPU和等待I/O的进程。<br>而CPU使用率是单位时间内CPU繁忙情况的统计，跟平均负载并不一定完全对应。</p>
<ul>
<li>CPU密集型进程，使用大量CPU会导致负载升高，此时两者一致</li>
<li>I/O密集型进程，等待I/O会导致平均负载升高，但CPU使用率不一定很高</li>
<li>大量等待CPU的进程调度也会导致平均负载升高，此时CPU使用率也会比较高</li>
</ul>
<p><img src="/images/cpu/%E7%94%B5%E8%AF%9D%E4%BA%AD-Load.png" alt="Linux load">cxsd<br><img src="/images/cpu/%E7%94%B5%E8%AF%9D%E4%BA%AD-CPU%E4%BD%BF%E7%94%A8%E7%8E%87.png" alt="Linux 使用率"></p>
<h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>Linux</li>
<li>stress Linux系统压力测试工具</li>
<li>sysstat 包含了常用的Linux性能工具，用来监控和分析系统性能。mpstat用来实时查看每个CPU的性能指标，以及所有CPU的平均指标。pidstat是一个进程性能分析工具，用来实时查看进程的CPU、内存、I/O以及上下文切换等性能指标</li>
</ul>
<h2 id="CPU密集型进程"><a href="#CPU密集型进程" class="headerlink" title="CPU密集型进程"></a>CPU密集型进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试之前的数据</span></span><br><span class="line">[root@test-monitor-alert-1 ~]# uptime</span><br><span class="line"> 19:59:55 up 27 days,  2:43,  7 users,  load average: 0.05, 0.07, 0.11</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 模拟两个CPU使用率100%</span></span><br><span class="line">[root@test-monitor-alert-1 ~]# stress --cpu 2 --timeout 600</span><br><span class="line">stress: info: [12880] dispatching hogs: 2 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uptime查看平均负载变化情况</span></span><br><span class="line">[root@test-monitor-alert-1 ~]# watch -d uptime</span><br><span class="line">Every 2.0s: uptime                                                                                                     Tue Nov 24 20:03:27 2020</span><br><span class="line"></span><br><span class="line"> 20:03:27 up 27 days,  2:47,  7 users,  load average: 1.98, 0.97, 0.45</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mpstat查看CPU使用情况  -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据</span></span><br><span class="line">[root@test-monitor-alert-1 sysstat-11.6.5]# ./mpstat -P ALL  5</span><br><span class="line">Linux 3.10.0-1127.19.1.el7.x86_64 (test-monitor-alert-1) 	11/25/2020 	_x86_64_	(4 CPU)</span><br><span class="line"></span><br><span class="line">09:26:34 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">09:26:39 AM  all    0.35    0.00    2.17   81.48    0.00    0.00    0.00    0.00    0.00   15.99</span><br><span class="line">09:26:39 AM    0    0.40    0.00    1.82   57.17    0.00    0.00    0.00    0.00    0.00   40.61</span><br><span class="line">09:26:39 AM    1    0.40    0.00    4.23   83.30    0.00    0.00    0.00    0.00    0.00   12.07</span><br><span class="line">09:26:39 AM    2    0.40    0.00    1.01   90.30    0.00    0.00    0.00    0.00    0.00    8.28</span><br><span class="line">09:26:39 AM    3    0.20    0.00    1.41   95.35    0.00    0.00    0.00    0.00    0.00    3.03</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 到底是哪个进程导致了 CPU 使用率为 100% 呢？你可以使用 pidstat 来查询：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间隔5秒后输出一组数据</span></span><br><span class="line"></span><br><span class="line">[root@test-monitor-farseer-1 sysstat-11.6.5]# dstat --top-io -d --top-bio -l</span><br><span class="line">----most-expensive---- -dsk/total- ----most-expensive---- ---load-avg---</span><br><span class="line">     i/o process      | read  writ|  block i/o process   | 1m   5m  15m</span><br><span class="line">docker-cont4376B 1002k|  16k   99k|systemd    9524B   58k|0.18 0.70 0.59</span><br><span class="line"></span><br><span class="line">prometheus   11k   11k|   0  1196k|prometheus    0  8192B|0.18 0.70 0.59</span><br><span class="line">barad_agent  42k   10k|8192B    0 |barad_agent   0    12k|0.16 0.69 0.59</span><br><span class="line">process-exp1462k   16k|  24k  320k|systemd-jou   0   260k|0.16 0.69 0.59</span><br><span class="line">stress-ng     0   744M|4792k  114M|stress-ng     0   744M|0.16 0.69 0.59</span><br><span class="line">stress-ng  1024M  281M|8192B  106M|stress-ng     0   280M|0.16 0.69 0.59</span><br><span class="line">barad_agent  23k 2367B|8192B  114M|prometheus    0  4096B|0.16 0.69 0.59</span><br><span class="line">YDService  9524B 1447B|  12k  111M|jbd2/vda1-8   0    28k|0.63 0.78 0.62</span><br><span class="line">systemd-jou  31k    0 |  12k   96M|systemd-jou   0   172k|0.63 0.78 0.62</span><br><span class="line">barad_agent4010B 2535B|  12k  111M|barad_agent   0  4096B|0.63 0.78 0.62</span><br><span class="line">YDService  6380B    0 |4096B  115M|jbd2/vda1-8   0    16k|0.63 0.78 0.62</span><br><span class="line">prometheus   11k   11k|  20k  104M|YDService    12k    0 |0.63 0.78 0.62</span><br><span class="line">barad_agent  42k   10k|8192B  107M|YDService    12k    0 |0.90 0.83 0.64</span><br><span class="line">stress-ng  1024M 1024M|  24k  108M|stress-ng     0  1024M|0.90 0.83 0.64</span><br><span class="line">YDService  4971B  164B|8192B  104M|prometheus    0  4096B|0.90 0.83 0.64</span><br><span class="line">systemd-jou6478B    0 |4096B  107M|systemd-jou   0    56k|0.90 0.83 0.64</span><br><span class="line">node_export  44k   11k|  16k  108M|jbd2/vda1-8   0   136k|0.90 0.83 0.64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pidsta版本问题，抓不出io <span class="built_in">wait</span></span></span><br><span class="line">[root@test-monitor-farseer-1 sysstat-11.6.5]# ./pidstat -u 5 1</span><br><span class="line">Linux 3.10.0-1127.19.1.el7.x86_64 (test-monitor-farseer-1) 	12/01/2020 	_x86_64_	(4 CPU)</span><br><span class="line"></span><br><span class="line">03:42:58 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">03:43:03 PM     0         9    0.00    0.20    0.00    0.20    0.20     1  rcu_sched</span><br><span class="line">03:43:03 PM     0        14    0.00    0.20    0.00    0.00    0.20     1  ksoftirqd/1</span><br><span class="line">03:43:03 PM     0        24    0.00    0.20    0.00    0.00    0.20     3  ksoftirqd/3</span><br><span class="line">03:43:03 PM     0       184    0.00    0.20    0.00    0.00    0.20     1  kauditd</span><br><span class="line">03:43:03 PM     0      1347    0.00    0.20    0.00    0.00    0.20     1  dockerd</span><br><span class="line">03:43:03 PM  1000      2066    1.20    1.20    0.00    0.00    2.40     0  java</span><br><span class="line">03:43:03 PM 65534      2525    0.20    0.00    0.00    0.00    0.20     1  prometheus</span><br><span class="line">03:43:03 PM     0      4926    0.20    0.00    0.00    0.00    0.20     2  docker-proxy</span><br><span class="line">03:43:03 PM     0      4950    0.00    0.40    0.00    0.00    0.40     3  etcd</span><br><span class="line">03:43:03 PM     0      5317    0.00    0.20    0.00    0.20    0.20     1  fs-monitor</span><br><span class="line">03:43:03 PM     0      9761  100.00    0.00    0.00    0.00  100.00     0  stress</span><br><span class="line">03:43:03 PM     0      9762   99.80    0.00    0.00    0.00   99.80     2  stress</span><br><span class="line">03:43:03 PM     0      9780    0.00    0.20    0.00    0.00    0.20     3  pidstat</span><br><span class="line">03:43:03 PM     0     26236    0.20    0.20    0.00    0.00    0.40     0  barad_agent</span><br><span class="line">03:43:03 PM     0     28925    0.00    0.40    0.00    0.00    0.40     1  YDService</span><br><span class="line">03:43:03 PM     0     28985    0.20    0.20    0.00    0.00    0.40     3  YDEdr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从这里可以明显看到，stress 进程的 CPU 使用率为 100%。</span></span><br></pre></td></tr></table></figure>

<h2 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试之前的数据</span></span><br><span class="line">[root@test-monitor-alert-1 ~]# uptime</span><br><span class="line"> 09:25:35 up 27 days,  3:21,  8 users,  load average: 0.35, 0.94, 0.60</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 模拟IO打满</span></span><br><span class="line">[root@test-monitor-alert-1 ~]#  stress-ng -i 1 --hdd 1 --timeout 600</span><br><span class="line">stress-ng: info:  [4710] dispatching hogs: 1 hdd, 1 io</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uptime查看平均负载变化情况</span></span><br><span class="line">[root@test-monitor-alert-1 ~]# watch -d uptime</span><br><span class="line">Every 2.0s: uptime                                                                                                     Wed Nov 25 09:25:38 2020</span><br><span class="line"></span><br><span class="line"> 09:25:38 up 27 days, 16:09,  4 users,  load average: 2.49, 0.69, 0.27</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mpstat查看CPU使用情况  -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据</span></span><br><span class="line">[root@test-monitor-alert-1 ~]# mpstat -P ALL  5</span><br><span class="line">Linux 3.10.0-1127.19.1.el7.x86_64 (test-monitor-alert-1) 	11/24/2020 	_x86_64_	(4 CPU)</span><br><span class="line"></span><br><span class="line">08:45:14 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">08:45:19 PM  all    0.75    0.00    1.86   89.53    0.00    0.00    0.00    0.00    0.00    7.85</span><br><span class="line">08:45:19 PM    0    0.61    0.00    2.42   91.92    0.00    0.00    0.00    0.00    0.00    5.05</span><br><span class="line">08:45:19 PM    1    0.80    0.00    2.20   76.15    0.00    0.00    0.00    0.00    0.00   20.84</span><br><span class="line">08:45:19 PM    2    0.81    0.00    1.21   92.74    0.00    0.00    0.00    0.00    0.00    5.24</span><br><span class="line">08:45:19 PM    3    0.80    0.00    1.41   97.59    0.00    0.00    0.00    0.00    0.00    0.20</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 pidstat 来查询到底是哪个进程导致了iowait这么高</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间隔5秒后输出一组数据</span></span><br><span class="line">[root@test-monitor-alert-1 sysstat-11.6.5]# ./pidstat -u 5 1</span><br><span class="line">Linux 3.10.0-1127.19.1.el7.x86_64 (test-monitor-alert-1) 	11/25/2020 	_x86_64_	(4 CPU)</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">Average:        0       275    0.00    0.60    0.00    0.00    0.60     -  kworker/0:1H</span><br><span class="line">Average:        0       292    0.00    2.60    0.00    0.00    2.60     -  jbd2/vda1-8</span><br><span class="line">Average:        0      1347    0.20    0.20    0.00    0.00    0.40     -  dockerd</span><br><span class="line">Average:        0      1472    0.40    0.20    0.00    0.00    0.60     -  node_exporter</span><br><span class="line">Average:        0      1598    0.00    0.20    0.00    0.00    0.20     -  docker-containe</span><br><span class="line">Average:     1000      2066    1.00    1.40    0.00    0.00    2.40     -  java</span><br><span class="line">Average:        0      4950    0.00    0.80    0.00    0.00    0.80     -  etcd</span><br><span class="line">Average:        0      5885    0.00   17.00    0.00    0.00   17.00     -  stress-ng-hdd</span><br><span class="line">Average:        0      5886    0.00    0.40    0.00    0.00    0.40     -  stress-ng-io</span><br><span class="line">Average:        0      5887    0.00    0.20    0.00    0.00    0.20     -  stress-ng-io</span><br><span class="line">Average:        0      8118    0.20    0.00    0.00    0.00    0.20     -  java</span><br><span class="line">Average:        0      8449    0.00    1.80    0.00    0.20    1.80     -  kworker/u8:0</span><br><span class="line">Average:        0      8458    0.20    0.20    0.00    0.00    0.40     -  java</span><br><span class="line">Average:        0     17111    0.00    0.20    0.00    0.20    0.20     -  kworker/3:0</span><br><span class="line">Average:        0     26173    0.00    0.20    0.00    0.00    0.20     -  notify</span><br><span class="line">Average:        0     26236    0.00    0.20    0.00    0.00    0.20     -  barad_agent</span><br><span class="line">Average:        0     28985    0.00    1.60    0.00    0.00    1.60     -  YDEdr</span><br></pre></td></tr></table></figure>

<h2 id="大量进程"><a href="#大量进程" class="headerlink" title="大量进程"></a>大量进程</h2><p>当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试之前的数据</span></span><br><span class="line">[root@test-monitor-alert-1 ~]# uptime</span><br><span class="line"> 09:44:17 up 27 days, 16:28,  4 users,  load average: 0.02, 1.90, 2.54</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 模拟多进程</span></span><br><span class="line">[root@test-monitor-alert-1 ~]# stress -c 8 --timeout 600</span><br><span class="line">stress: info: [9683] dispatching hogs: 8 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uptime查看平均负载变化情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于系统只有 4 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 8.08</span></span><br><span class="line">[root@test-monitor-alert-1 ~]# watch -d uptime</span><br><span class="line">Every 2.0s: uptime                                                                                                     Wed Nov 25 09:47:07 2020</span><br><span class="line"></span><br><span class="line"> 09:47:08 up 27 days, 16:31,  4 users,  load average: 8.08, 3.72, 3.05</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 pidstat 来看一下进程的情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间隔5秒后输出一组数据</span></span><br><span class="line">[root@test-monitor-alert-1 sysstat-11.6.5]# ./pidstat -u 5 1</span><br><span class="line">Linux 3.10.0-1127.19.1.el7.x86_64 (test-monitor-alert-1) 	11/25/2020 	_x86_64_	(4 CPU)</span><br><span class="line"></span><br><span class="line">09:47:44 AM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">09:47:49 AM  1000      2066    1.59    0.20    0.00    0.00    1.79     0  java</span><br><span class="line">09:47:49 AM 65534      2525    0.20    0.00    0.00    0.00    0.20     1  prometheus</span><br><span class="line">09:47:49 AM     0      4950    0.20    0.20    0.00    1.39    0.40     2  etcd</span><br><span class="line">09:47:49 AM     0      8118    0.00    0.20    0.00    0.00    0.20     0  java</span><br><span class="line">09:47:49 AM     0      8458    0.20    0.00    0.00    0.00    0.20     1  java</span><br><span class="line">09:47:49 AM     0      9290    0.20    0.00    0.00    0.20    0.20     3  watch</span><br><span class="line">09:47:49 AM     0      9684   64.94    0.00    0.00   34.66   64.94     2  stress</span><br><span class="line">09:47:49 AM     0      9685   40.24    0.00    0.00   59.56   40.24     1  stress</span><br><span class="line">09:47:49 AM     0      9686   44.02    0.00    0.00   55.58   44.02     2  stress</span><br><span class="line">09:47:49 AM     0      9687   46.81    0.00    0.00   52.79   46.81     0  stress</span><br><span class="line">09:47:49 AM     0      9688   41.43    0.00    0.00   58.37   41.43     1  stress</span><br><span class="line">09:47:49 AM     0      9689   49.00    0.00    0.00   50.20   49.00     0  stress</span><br><span class="line">09:47:49 AM     0      9690   55.58    0.00    0.00   44.42   55.58     3  stress</span><br><span class="line">09:47:49 AM     0      9691   52.59    0.00    0.00   47.41   52.59     2  stress</span><br><span class="line">09:47:49 AM     0     26155    0.00    0.20    0.00    0.00    0.20     0  docker-containe</span><br><span class="line">09:47:49 AM     0     26236    0.20    0.20    0.00    0.00    0.40     2  barad_agent</span><br><span class="line">09:47:49 AM   999     28742    0.20    0.00    0.00    0.00    0.20     1  mysqld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看出，8 个进程在争抢 4 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %<span class="built_in">wait</span> 列）高达 50%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</span></span><br></pre></td></tr></table></figure>

<pre><code>平均负载高有可能是 CPU 密集型进程导致的；
平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；
当发现负载高的时候，可以使用 mpstat、pidstat 等工具，辅助分析负载的来源</code></pre>
<h2 id="CPU寄存器、程序计数器：CPU上下文"><a href="#CPU寄存器、程序计数器：CPU上下文" class="headerlink" title="CPU寄存器、程序计数器：CPU上下文"></a>CPU寄存器、程序计数器：CPU上下文</h2><p>CPU寄存器是CPU中内置的容量小、速度极快的内存。<br>程序计数器用来存储CPU正在执行的指令位置、或者即将执行的下一条指令的位置。他们都是CPU在运行任何任务前必须依赖的环境，因此也可以称作CPU上下文。</p>
<ul>
<li>PC</li>
<li>IR</li>
<li>PSR</li>
</ul>
<p><img src="/images/cpu/CPU%E5%B7%A5%E4%BD%9C%E5%9B%BE.png" alt="CPU上下文"></p>
<h1 id="CPU上下文切换"><a href="#CPU上下文切换" class="headerlink" title="CPU上下文切换"></a>CPU上下文切换</h1><p>进程在竞争CPU的时候并未真正运行，导致系统负载过高的原因就是CPU上下文切换。<br>Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。<br>在任务运行前CPU都需要知道任务从哪里加载、从哪里运行，简单来说CPU需要系统事先帮它设置好CPU寄存器和程序计数器。</p>
<p>CPU上下文切换就是包前一个任务的CPU上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，然后跳转到程序计数器所指的新位置运行新任务。</p>
<h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h2><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。如图：</p>
<p><img src="/images/cpu/%E7%89%B9%E6%9D%83%E7%AD%89%E7%BA%A7.png" alt="特权等级"></p>
<ul>
<li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li>
<li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li>
</ul>
<p>进程既可以在用户空间（用户态）运行又可以在内核（内核态）空间运行。进程从用户态到内核态到转变需要通过<code>系统调用</code>来完成。<br>在系统调用到过程中CPU发生了上下文切换。</p>
<p><code>CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。</code></p>
<pre><code>系统调用过程中，并不涉及虚拟内存等进程用户态的资源，也不会切换进程。所以这里的切换和进程切换是有区别的：
1. 进程上下文切换是从一个进程切换到另一个进程
2. 系统调用过程中，始终在同一个进程在运行。</code></pre>
<p>所以系统调用是一种特权模式的切换。</p>
<h2 id="进程调度和系统调用区别"><a href="#进程调度和系统调用区别" class="headerlink" title="进程调度和系统调用区别"></a>进程调度和系统调用区别</h2><p>进程由内核管理和调度的，所以进程切换是发生在内核态的。进程的上下文不仅包括了内存、堆栈等，还包含了内核堆栈、寄存器等内核空的状态。<br>所以进程上下文切换比系统调用多了一步，<code>在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈</code>。 如图：</p>
<p><img src="/images/cpu/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2.png" alt="CPU上下文"></p>
<h2 id="什么时候会进行上下文切换"><a href="#什么时候会进行上下文切换" class="headerlink" title="什么时候会进行上下文切换"></a>什么时候会进行上下文切换</h2><ul>
<li>进程时间片耗尽就会被系统挂起，切换到其它等待进程（为了保证进程公平调度，CPU的时间被划分为一段段时间片，轮流分配给各个进程）</li>
<li>进程资源不足时，要等到资源满足才可以运行，这个时候进程也会被挂起</li>
<li>进程通过睡眠函数sleep将自己挂起时，也会发生调度</li>
<li>有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程可能被挂起</li>
<li>发生硬件中断的时候，CPU上的进程也会被挂起，来执行内核中断服务</li>
</ul>
<p>进程切换的时候会发生上下文恰换，Linux为每个CPU都维护了一个就绪队列，将活跃进程按照优先级和等待CPU的时间排序，选择最需要CPU的进程，也就是优先级和等待CPU时间最长的进程来运行。下面整理来几种进程切换的场景：</p>
<h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>线程是调度的基本单位，而进程则是资源拥有的基本单位。<code>内核的任务调度实际上是对线程的调度，进程只是为线程提供了虚拟内存、全局变量等资源</code>。</p>
<ul>
<li>当进程只有一个线程的时候，进程对于线程</li>
<li>当进程拥有多个线程时，共享虚拟内存、全局变量等资源，这些数据在上下文切换时不需保存</li>
<li>多个线程各自拥有自己的私有数据，上下文切换时时需要保存的</li>
</ul>
<h2 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h2><p>中断是为了快速响应硬件的事件，中断的优先级比进程高，对被打断对进程来说，需要将当前状态保存下来，以便之后进程恢复运行。<br>和进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括CPU寄存器、内核堆栈、硬件中断参数等。</p>
<h2 id="查看系统上下文切换"><a href="#查看系统上下文切换" class="headerlink" title="查看系统上下文切换"></a>查看系统上下文切换</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每隔5秒输出1组数据</span></span><br><span class="line">[root@test-tke-node-k21 ~]# vmstat 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  1      0 16538480 238900 12508012    0    0     5   166    0    0  6  6 88  0  0</span><br><span class="line"> 0  0      0 16540000 238900 12508004    0    0     0   258 11200 18214  6  2 92  0  0</span><br><span class="line"> 0  0      0 16542944 238900 12508124    0    0     0   273 11778 19454  7  2 92  0  0</span><br></pre></td></tr></table></figure>

<ul>
<li>cs（context switch）是每秒上下文切换的次数</li>
<li>in（interrupt）则是每秒中断的次数</li>
<li>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数</li>
<li>b（Blocked）则是处于不可中断睡眠状态的进程数</li>
</ul>
<h3 id="Procs（进程）："><a href="#Procs（进程）：" class="headerlink" title="Procs（进程）："></a>Procs（进程）：</h3><ul>
<li>r: 运行队列中进程数量</li>
<li>b： 等待IO的进程数量</li>
</ul>
<h3 id="Memory（内存）："><a href="#Memory（内存）：" class="headerlink" title="Memory（内存）："></a>Memory（内存）：</h3><ul>
<li>swpd: 使用虚拟内存大小</li>
<li>free: 可用内存大小</li>
<li>buff: 用作缓冲的内存大小</li>
<li>cache: 用作缓存的内存大小</li>
</ul>
<h3 id="Swap："><a href="#Swap：" class="headerlink" title="Swap："></a>Swap：</h3><ul>
<li>si: 每秒从交换区写到内存的大小</li>
<li>so: 每秒写入交换区的内存大小</li>
</ul>
<h3 id="IO：（现在的Linux版本块的大小为1024bytes）"><a href="#IO：（现在的Linux版本块的大小为1024bytes）" class="headerlink" title="IO：（现在的Linux版本块的大小为1024bytes）"></a>IO：（现在的Linux版本块的大小为1024bytes）</h3><ul>
<li>bi: 每秒读取的块数</li>
<li>bo: 每秒写入的块数</li>
</ul>
<h3 id="系统："><a href="#系统：" class="headerlink" title="系统："></a>系统：</h3><ul>
<li>in: 每秒中断数，包括时钟中断。【interrupt】</li>
<li>cs: 每秒上下文切换数。        【count/second】</li>
</ul>
<h3 id="CPU（以百分比表示）："><a href="#CPU（以百分比表示）：" class="headerlink" title="CPU（以百分比表示）："></a>CPU（以百分比表示）：</h3><ul>
<li>us: 用户进程执行时间(user time)</li>
<li>sy: 系统进程执行时间(system time)</li>
<li>id: 空闲时间(包括IO等待时间),中央处理器的空闲时间 。以百分比表示。</li>
<li>wa: 等待IO时间</li>
</ul>
<h3 id="查看每个进程上下文切换的情况"><a href="#查看每个进程上下文切换的情况" class="headerlink" title="查看每个进程上下文切换的情况"></a>查看每个进程上下文切换的情况</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每隔5秒输出1组数据</span></span><br><span class="line">[root@test-tke-node-k21 ~]# pidstat -w 5</span><br><span class="line">Linux 4.14.105-19-0012 (test-tke-node-k21) 	11/30/2020 	_x86_64_	(16 CPU)</span><br><span class="line"></span><br><span class="line">08:26:23 PM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:26:28 PM     0         1      1.39      0.00  systemd</span><br><span class="line">08:26:28 PM     0       408      2.39      0.00  jbd2/vda1-8</span><br><span class="line">08:26:28 PM     0       821      1.00      0.00  auditd</span><br><span class="line">08:26:28 PM    81       851      2.19      0.00  dbus-daemon</span><br><span class="line">08:26:28 PM     0       854     81.67      0.00  systemd-logind</span><br><span class="line">08:26:28 PM     0      2603     17.73      0.00  xfsaild/vdb</span><br><span class="line">08:26:28 PM     0      5856      0.40      0.00  ip-masq-agent</span><br><span class="line">08:26:28 PM     0    176333      0.20      0.00  docker-containe</span><br><span class="line">08:26:28 PM    99    247899      1.39      0.00  dnsmasq</span><br><span class="line">08:26:28 PM  1000    818340      1.79      0.00  php-fpm</span><br><span class="line">08:26:28 PM  1000    818678      0.20      0.00  php-fpm</span><br><span class="line">08:26:28 PM     0    879677      1.99      0.00  wukong-go</span><br><span class="line">08:26:28 PM     0    879734      0.40      0.00  wukong-go</span><br><span class="line">08:26:28 PM     0   1133084      0.20      0.00  docker-containe</span><br><span class="line">08:26:28 PM     0   1322604     79.68      4.58  kube-proxy</span><br><span class="line">08:26:28 PM     0   1396221      0.20      0.00  log-collector</span><br><span class="line">08:26:28 PM     0   1396237      1.99      0.00  fluentd</span><br><span class="line">08:26:28 PM     0   1396247      3.19      0.00  ruby</span><br></pre></td></tr></table></figure>

<ul>
<li>cswch表示每秒自愿上下文切换（voluntary context switches）的次数(自愿上下文切换，指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。（当某一任务处于阻塞等待时等等）)</li>
<li>nvcswch表示每秒非自愿上下文切换（non voluntary context switches）的次数（非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换）</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 间隔1秒后输出1组数据</span></span><br><span class="line">[root@test-tke-node-k21 ~]# vmstat 1 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0      0 16466196 238908 12583356    0    0     5   166    0    0  6  6 88  0  0</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以10个线程运行5分钟的基准测试，模拟多线程切换的问题</span></span><br><span class="line">[root@test-tke-node-k21 ~]# sysbench --threads=10 --max-time=300 threads run</span><br><span class="line">WARNING: --max-time is deprecated, use --time instead</span><br><span class="line">sysbench 1.0.17 (using system LuaJIT 2.0.4)</span><br><span class="line"></span><br><span class="line">Running the test with following options:</span><br><span class="line">Number of threads: 10</span><br><span class="line">Initializing random number generator from current time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initializing worker threads...</span><br><span class="line"></span><br><span class="line">Threads started!</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test-tke-node-k21 ~]# vmstat 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 每隔1秒输出1组数据</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">14  0      0 16321480 239636 12712368    0    0     5   166    0    0  6  6 88  0  0</span><br><span class="line"> 9  0      0 16322324 239636 12712316    0    0     0     0 180878 783183 16 36 48  0  0</span><br><span class="line">10  0      0 16322848 239636 12712316    0    0     0   524 95575 820357 16 35 49  0  0</span><br><span class="line">10  0      0 16322512 239636 12712500    0    0     0   488 101780 821691 14 37 49  0  0</span><br><span class="line">12  0      0 16322304 239636 12712332    0    0     0   116 118060 804412 20 36 44  0  0</span><br><span class="line"> 9  0      0 16322612 239636 12712408    0    0     0     0 159525 754018 22 36 42  0  0</span><br><span class="line">11  0      0 16307728 239636 12712464    0    0     0   524 88452 829684 15 36 49  0  0</span><br><span class="line"> 8  0      0 16324056 239636 12712364    0    0     0     0 96059 826541 15 36 49  0  0</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每隔1秒输出1组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标</span></span><br><span class="line">[root@test-tke-node-k21 ~]# pidstat -w -u 1</span><br><span class="line">Linux 4.14.105-19-0012 (test-tke-node-k21) 	11/30/2020 	_x86_64_	(16 CPU)</span><br><span class="line"></span><br><span class="line">09:04:51 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">09:04:52 PM     0         1    0.00    0.98    0.00    0.98    15  systemd</span><br><span class="line">09:04:52 PM     0       854    0.98    0.00    0.00    0.98     6  systemd-logind</span><br><span class="line">09:04:52 PM     0      3475    1.96    0.00    0.00    1.96     8  dockerd</span><br><span class="line">09:04:52 PM     0      3488    0.00    0.98    0.00    0.98    14  docker-containe</span><br><span class="line">09:04:52 PM     0      3581    2.94    0.00    0.00    2.94     6  kubelet</span><br><span class="line">09:04:52 PM     0    153780  100.00  100.00    0.00  100.00    11  sysbench</span><br><span class="line">09:04:52 PM     0    154330    0.00    1.96    0.00    1.96     7  pidstat</span><br><span class="line">09:04:52 PM     0   1741126    0.00    0.98    0.00    0.98     9  wukong-go</span><br><span class="line">09:04:52 PM     0   1847481    0.98    0.00    0.00    0.98     7  wukong-go</span><br><span class="line">09:04:52 PM     0   1968378    0.98    0.00    0.00    0.98     8  wukong-go</span><br><span class="line">09:04:52 PM     0   2035882    0.98    0.00    0.00    0.98     7  YDEdr</span><br><span class="line">09:04:52 PM     0   2245987    0.00    0.98    0.00    0.98    10  wukong-go</span><br><span class="line">09:04:52 PM     0   2491812    0.98    0.00    0.00    0.98     7  barad_agent</span><br><span class="line">09:04:52 PM     0   2726307    0.98    0.00    0.00    0.98     1  wukong-go</span><br><span class="line">09:04:52 PM     0   2726406    0.00    0.98    0.00    0.98     9  docker-containe</span><br><span class="line">09:04:52 PM     0   3205475    5.88    0.00    0.00    5.88     9  wukong-go</span><br><span class="line"></span><br><span class="line">09:04:51 PM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">09:04:52 PM     0         1      1.96      0.00  systemd</span><br><span class="line">09:04:52 PM     0         7      6.86      0.00  ksoftirqd/0</span><br><span class="line">09:04:52 PM     0         8    128.43      0.00  rcu_sched</span><br><span class="line">09:04:52 PM     0        10      0.98      0.00  migration/0</span><br><span class="line">09:04:52 PM     0        11      0.98      0.00  watchdog/0</span><br><span class="line">09:04:52 PM     0        14      0.98      0.00  watchdog/1</span><br><span class="line">09:04:52 PM     0        16      2.94      0.00  ksoftirqd/1</span><br><span class="line">09:04:52 PM     0        20      0.98      0.00  watchdog/2</span><br><span class="line">09:04:52 PM     0        22      0.98      0.00  ksoftirqd/2</span><br><span class="line">09:04:52 PM     0        26      0.98      0.00  watchdog/3</span><br><span class="line">09:04:52 PM     0        28      0.98      0.00  ksoftirqd/3</span><br><span class="line">09:04:52 PM     0        32      0.98      0.00  watchdog/4</span><br><span class="line">09:04:52 PM     0        33      0.98      0.00  migration/4</span><br><span class="line">09:04:52 PM     0        38      0.98      0.00  watchdog/5</span><br><span class="line">09:04:52 PM     0        44      0.98      0.00  watchdog/6</span><br><span class="line">09:04:52 PM     0        46      0.98      0.00  ksoftirqd/6</span><br><span class="line">09:04:52 PM     0        50      0.98      0.00  watchdog/7</span><br><span class="line">09:04:52 PM     0        56      0.98      0.00  watchdog/8</span><br><span class="line">09:04:52 PM     0        58      0.98      0.00  ksoftirqd/8</span><br><span class="line">09:04:52 PM     0        64      0.98      0.00  ksoftirqd/9</span><br><span class="line">09:04:52 PM     0        70      0.98      0.00  ksoftirqd/10</span><br><span class="line">09:04:52 PM     0        76      1.96      0.00  ksoftirqd/11</span><br><span class="line">09:04:52 PM     0        88     11.76      0.00  ksoftirqd/13</span><br><span class="line">09:04:52 PM     0        94     14.71      0.00  ksoftirqd/14</span><br><span class="line">09:04:52 PM     0       100      4.90      0.00  ksoftirqd/15</span><br><span class="line">09:04:52 PM   998       846      0.98      0.00  lsmd</span><br><span class="line">09:04:52 PM    81       851      1.96      0.00  dbus-daemon</span><br><span class="line">09:04:52 PM     0       854     82.35      0.00  systemd-logind</span><br><span class="line">09:04:52 PM     0      2603     17.65      0.00  xfsaild/vdb</span><br><span class="line">09:04:52 PM     0      5856      0.98      0.00  ip-masq-agent</span><br><span class="line">09:04:52 PM     0     40848      1.96      0.00  kworker/9:0</span><br><span class="line">09:04:52 PM     0     54827      3.92      0.00  kworker/8:3</span><br><span class="line">09:04:52 PM     0     63763      1.96      0.00  kworker/13:1</span><br><span class="line">09:04:52 PM     0     77632      1.96      0.00  kworker/2:0</span><br><span class="line">09:04:52 PM     0     90968      4.90      0.00  kworker/11:2</span><br><span class="line">09:04:52 PM     0     95640      1.96      0.00  kworker/4:1</span><br><span class="line">09:04:52 PM     0    109150      0.98      0.00  kworker/6:1</span><br><span class="line">09:04:52 PM     0    109261      2.94      0.00  kworker/12:1</span><br><span class="line">09:04:52 PM     0    113800      3.92      0.00  kworker/5:3</span><br><span class="line">09:04:52 PM     0    116666      2.94      0.00  kworker/1:0</span><br><span class="line">09:04:52 PM     0    125144      9.80      0.00  kworker/3:1</span><br><span class="line">09:04:52 PM     0    127807      4.90      0.00  kworker/7:0</span><br><span class="line">09:04:52 PM     0    132114      8.82      0.00  kworker/0:1</span><br><span class="line">09:04:52 PM     0    141303      6.86      0.00  kworker/15:0</span><br><span class="line">09:04:52 PM    89    146085      0.98      0.00  trivial-rewrite</span><br><span class="line">09:04:52 PM     0    146091      1.96      0.00  kworker/14:0</span><br><span class="line">09:04:52 PM     0    149169      8.82      0.00  kworker/10:1</span><br><span class="line">09:04:52 PM     0    154330      0.98      0.00  pidstat</span><br><span class="line">09:04:52 PM    99    247899      1.96      0.00  dnsmasq</span><br><span class="line">09:04:52 PM  1000    818340      0.98      0.00  php-fpm</span><br><span class="line">09:04:52 PM     0   1396237      1.96      0.00  fluentd</span><br><span class="line">09:04:52 PM     0   1396247      2.94      0.00  ruby</span><br><span class="line">09:04:52 PM     0   2035882      0.98      0.00  YDEdr</span><br><span class="line">09:04:52 PM     0   2491811      2.94      0.00  barad_agent</span><br><span class="line">09:04:52 PM     0   2522357      4.90      0.00  wukong-go</span><br><span class="line">09:04:52 PM     0   2726406      0.98      0.00  docker-containe</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line">[root@test-tke-node-k21 ~]# pidstat -wt -u 1 | grep sysbench</span><br><span class="line">[root@test-tke-node-k21 ~]# pidstat -wt -u 1</span><br><span class="line">Linux 4.14.105-19-0012 (test-tke-node-k21) 	11/30/2020 	_x86_64_	(16 CPU)</span><br><span class="line"></span><br><span class="line">10:31:49 PM   UID      TGID       TID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">10:31:50 PM     0         1         -    0.90    0.00    0.00    0.90     1  systemd</span><br><span class="line">10:31:50 PM     0    548753         -  100.00  100.00    0.00  100.00    11  sysbench</span><br><span class="line">10:31:50 PM     0         -    548754   27.03   64.86    0.00   91.89    10  |__sysbench</span><br><span class="line">10:31:50 PM     0         -    548755   27.93   63.96    0.00   91.89     5  |__sysbench</span><br><span class="line">10:31:50 PM     0         -    548756   32.43   60.36    0.00   92.79     2  |__sysbench</span><br><span class="line">10:31:50 PM     0         -    548757   23.42   68.47    0.00   91.89    11  |__sysbench</span><br><span class="line">10:31:50 PM     0         -    548758   25.23   67.57    0.00   92.79     6  |__sysbench</span><br><span class="line">10:31:50 PM     0         -    548759   24.32   67.57    0.00   91.89     7  |__sysbench</span><br><span class="line">10:31:50 PM     0         -    548760   24.32   67.57    0.00   91.89    13  |__sysbench</span><br><span class="line">10:31:50 PM     0         -    548761   27.03   65.77    0.00   92.79     4  |__sysbench</span><br><span class="line">10:31:50 PM     0         -    548762   23.42   68.47    0.00   91.89    12  |__sysbench</span><br><span class="line">10:31:50 PM     0         -    548763   25.23   65.77    0.00   90.99     3  |__sysbench</span><br><span class="line"></span><br><span class="line">Average:      UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">Average:        0         -    548754  37902.70     15.32  |__sysbench</span><br><span class="line">Average:        0         -    548755  39209.01     27.93  |__sysbench</span><br><span class="line">Average:        0         -    548756  38840.54     26.13  |__sysbench</span><br><span class="line">Average:        0         -    548757  41057.66      8.11  |__sysbench</span><br><span class="line">Average:        0         -    548758  38201.80     15.32  |__sysbench</span><br><span class="line">Average:        0         -    548759  41139.64      6.31  |__sysbench</span><br><span class="line">Average:        0         -    548760  37354.05     69.37  |__sysbench</span><br><span class="line">Average:        0         -    548761  39441.44     17.12  |__sysbench</span><br><span class="line">Average:        0         -    548762  38177.48     28.83  |__sysbench</span><br><span class="line">Average:        0         -    548763  41107.21     40.54  |__sysbench</span><br><span class="line">Average:        0    549036         -      0.90      1.80  pidstat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ....</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 观察中断的变化情况</span></span><br><span class="line">[root@test-tke-node-k21 ~]# watch -d cat /proc/interrupts</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /proc/interrupts</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左至右：中断号   中断次数  中断设备名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如下图</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/cpu/interrupts.jpg" alt="中断观察"></p>
<p>重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）。</p>
<ul>
<li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题</li>
<li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈</li>
<li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。</li>
</ul>
<h1 id="CPU-100-之后该怎么办"><a href="#CPU-100-之后该怎么办" class="headerlink" title="CPU 100%之后该怎么办"></a>CPU 100%之后该怎么办</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数</span></span><br><span class="line">[root@test-tke-node-k21 ~]# perf top</span><br><span class="line"><span class="meta">#</span><span class="bash">  perf top -g 开启调用关系的采样，方便根据调用链来分析性能问题</span></span><br><span class="line">Samples: 157K of event &#x27;cpu-clock&#x27;, Event count (approx.): 35995554317</span><br><span class="line">Overhead  Shared Object           Symbol                                                                                                    ◆</span><br><span class="line">  18.11%  [kernel]                [k] _raw_spin_unlock_irqrestore                                                                           ▒</span><br><span class="line">  14.61%  [kernel]                [k] __sched_text_start                                                                                    ▒</span><br><span class="line">  12.29%  [kernel]                [k] do_syscall_64                                                                                         ▒</span><br><span class="line">   9.64%  libc-2.17.so            [.] __sched_yield                                                                                         ▒</span><br><span class="line">   7.43%  libpthread-2.17.so      [.] pthread_mutex_unlock                                                                                  ▒</span><br><span class="line">   7.34%  [kernel]                [k] finish_task_switch                                                                                    ▒</span><br><span class="line">   2.41%  libpthread-2.17.so      [.] pthread_mutex_lock                                                                                    ▒</span><br><span class="line">   1.64%  [kernel]                [k] tick_nohz_idle_enter                                                                                  ▒</span><br><span class="line">   1.41%  libpthread-2.17.so      [.] __lll_lock_wait                                                                                       ▒</span><br><span class="line">   1.32%  [kernel]                [k] __audit_syscall_exit                                                                                  ▒</span><br><span class="line">   1.21%  [kernel]                [k] __pv_queued_spin_lock_slowpath                                                                        ▒</span><br><span class="line">   0.96%  [kernel]                [k] tick_nohz_idle_exit                                                                                   ▒</span><br><span class="line">   0.91%  [kernel]                [k] __audit_syscall_entry                                                                                 ▒</span><br><span class="line">   0.90%  libpthread-2.17.so      [.] __lll_unlock_wake                                                                                     ▒</span><br><span class="line">   0.67%  [kernel]                [k] futex_wake                                                                                            ▒</span><br><span class="line">   0.65%  [kernel]                [k] syscall_trace_enter                                                                                   ▒</span><br><span class="line">   0.65%  kubelet                 [.] _start                                                                                                ▒</span><br><span class="line">   0.65%  [kernel]                [k] do_idle                                                                                               ▒</span><br></pre></td></tr></table></figure>

<ul>
<li>Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示</li>
<li>Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等</li>
<li>Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间</li>
<li>Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示</li>
</ul>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行测试服务</span></span><br><span class="line">[root@test-tke-node-k21 ~]# docker run --name nginx -p 10000:80 -itd feisky/nginx</span><br><span class="line">[root@test-tke-node-k21 ~]# docker run --name phpfpm -itd --network container:nginx feisky/php-fpm</span><br><span class="line"></span><br><span class="line">[root@test-tke-node-k21 ~]# top</span><br><span class="line">top - 11:07:07 up 127 days, 20:52,  2 users,  load average: 1.92, 1.42, 1.55</span><br><span class="line">Tasks: 450 total,   6 running, 318 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s): 41.0 us,  3.6 sy,  0.0 ni, 53.8 id,  0.0 wa,  0.0 hi,  1.6 si,  0.0 st</span></span><br><span class="line">KiB Mem : 32412656 total, 15455832 free,  3158432 used, 13798392 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 29064108 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">1322604 root      20   0  212268  78780      0 S 189.9  0.2  54644:05 kube-proxy</span><br><span class="line">3973285 bin       20   0  336696  16352   8664 R  98.7  0.1   0:08.04 php-fpm</span><br><span class="line">3973319 bin       20   0  336696  13200   5520 R  98.7  0.0   0:07.96 php-fpm</span><br><span class="line">3973320 bin       20   0  336696  13136   5456 R  98.7  0.0   0:07.95 php-fpm</span><br><span class="line">3973321 bin       20   0  336696  13076   5396 R  98.7  0.0   0:07.88 php-fpm</span><br><span class="line">3973322 bin       20   0  336696  13140   5460 R  98.7  0.0   0:07.88 php-fpm</span><br><span class="line">   3581 root      20   0 2122004 160940  18672 S  11.4  0.5   7908:01 kubelet</span><br><span class="line">2962155 root      20   0  729632  55472  12772 S  10.1  0.2 102:22.64 wukong-go</span><br><span class="line">   3475 root      20   0 2384864 144036  18664 S   3.8  0.4  18601:39 dockerd</span><br><span class="line">2035882 root      20   0  841168  17044  11040 S   2.5  0.1 151:47.57 YDEdr</span><br><span class="line">3971722 root      20   0   12568   6140   1476 S   2.5  0.0   0:00.26 docker-proxy</span><br><span class="line">      1 root      20   0  192996   7132   3692 S   1.3  0.0 620:19.81 systemd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> perf 看出 add_function sqrt 消耗比较大</span></span><br><span class="line">[root@test-tke-node-k21 ~]# perf top -g -p 3973285</span><br><span class="line">Samples: 111K of event &#x27;cpu-clock&#x27;, Event count (approx.): 14077224392</span><br><span class="line">  Overhead  Shared Object                      Symbol                                                                                   ◆</span><br><span class="line">-    5.91%  php-fpm                            [.] add_function                                                                         ▒</span><br><span class="line">   - 5.91% add_function                                                                                                                 ▒</span><br><span class="line">      + 5.14% 0x98dd97                                                                                                                  ▒</span><br><span class="line">-    5.74%  libm-2.24.so                       [.] sqrt                                                                                 ▒</span><br><span class="line">     sqrt                                                                                                                               ▒</span><br><span class="line">     0x8c4a7c                                                                                                                           ▒</span><br><span class="line">     execute_ex                                                                                                                         ▒</span><br><span class="line">     zend_execute                                                                                                                       ▒</span><br><span class="line">     zend_execute_scripts                                                                                                               ▒</span><br><span class="line">     php_execute_script                                                                                                                 ▒</span><br><span class="line">     0x9cb642                                                                                                                           ▒</span><br><span class="line">     __libc_start_main                                                                                                                  ▒</span><br><span class="line">     0x6cb6258d4c544155                                                                                                                 ▒</span><br><span class="line">+    4.87%  php-fpm                            [.] execute_ex                                                                           ▒</span><br><span class="line">+    2.45%  php-fpm                            [.] 0x000000000094ede0                                                                   ▒</span><br><span class="line">+    1.55%  php-fpm                            [.] 0x0000000000681b9d                                                                   ▒</span><br><span class="line">+    0.95%  php-fpm                            [.] 0x00000000008cd720                                                                   ▒</span><br><span class="line">+    0.80%  php-fpm                            [.] 0x0000000000681d21                                                                   ▒</span><br><span class="line">+    0.79%  php-fpm                            [.] 0x0000000000681d1a                                                                   ▒</span><br><span class="line">+    0.74%  php-fpm                            [.] 0x000000000098dc03</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导出源码</span></span><br><span class="line">[root@test-tke-node-k21 ~]# docker cp phpfpm:/app .</span><br><span class="line">[root@test-tke-node-k21 ~]# grep sqrt -r app/</span><br><span class="line">app/index.php:  $x += sqrt($x);</span><br><span class="line"><span class="meta">#</span><span class="bash"> add_function是php内置函数，这里看不到</span></span><br><span class="line">[root@test-tke-node-k21 ~]# grep add_function -r app/</span><br><span class="line">[root@test-tke-node-k21 ~]# cat app/index.php</span><br><span class="line">&lt;?php</span><br><span class="line">// test only.</span><br><span class="line"><span class="meta">$</span><span class="bash">x = 0.0001;</span></span><br><span class="line">for ($i = 0; $i &lt;= 1000000; $i++) &#123;</span><br><span class="line"><span class="meta">  $</span><span class="bash">x += sqrt(<span class="variable">$x</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;It works!&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止原来的应用</span></span><br><span class="line">[root@test-tke-node-k21 ~] docker rm -f nginx phpfpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行优化后的应用</span></span><br><span class="line">[root@test-tke-node-k21 ~] docker run --name nginx -p 10000:80 -itd feisky/nginx:cpu-fix</span><br><span class="line">[root@test-tke-node-k21 ~] docker run --name phpfpm -itd --network container:nginx feisky/php-fpm:cpu-fix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用下面的方式去排查</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 记录性能事件，等待大约15秒后按 Ctrl+C 退出</span></span><br><span class="line">[root@test-tke-node-k21 ~] perf record -g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看报告</span></span><br><span class="line">[root@test-tke-node-k21 ~] perf report</span><br><span class="line"></span><br><span class="line">[root@test-tke-node-k21 bin]# dstat 1 10</span><br><span class="line">You did not select any stats, using -cdngy by default.</span><br><span class="line">----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw</span><br><span class="line">  6   2  88   0   0   3|  73k 2632k|   0     0 |   0     0 |  11k   35k</span><br><span class="line">  0   0  99   0   0   0|4096B  608k| 108k  122k|   0     0 |7080    12k</span><br><span class="line">  9   2  89   0   0   0|   0   472k| 111k  128k|   0     0 |8503    13k</span><br><span class="line">  5   2  93   0   0   0|4096B  108k| 125k  231k|   0     0 |  10k   16k</span><br><span class="line">  1   0  99   0   0   0|  16k  548k|  92k  102k|   0     0 |5700  9569</span><br><span class="line">  2   1  97   0   0   0|8192B    0 |  87k  158k|   0     0 |  15k   25k</span><br><span class="line">  7   3  90   0   0   0|4096B    0 | 121k   87k|   0     0 |  18k   30kq</span><br><span class="line"> 15   3  82   0   0   0|   0   656k|  76k  175k|   0     0 |  14k   23k</span><br></pre></td></tr></table></figure>


<h1 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h1><p>中断处理程序在响应中断时，还会临时关闭中断。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。<br>Linux 将中断处理过程分成了两个阶段上半部和下半部，这样做的原因是<code>为了减少对正常进程运行调度的影响</code>，同时中断处理程序需要尽可能快地运行。</p>
<ul>
<li>上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作</li>
<li>下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行</li>
</ul>
<p>网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。<br>这时，内核就应该调用中断处理程序来响应它。</p>
<ol>
<li>对上半部来说，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了）</li>
<li>最后再发送一个软中断信号，通知下半部做进一步的处理。</li>
<li>下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。</li>
</ol>
<p>总结来说：</p>
<ul>
<li>上半部直接处理硬件请求，也就是硬中断，特点是快速执行</li>
<li>下半部则是由内核触发，也就是软中断，特点是延迟执行</li>
</ul>
<p>实际上，上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU 编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 软中断内核线程就叫做 ksoftirqd/CPU 编号， 查看方式</span></span><br><span class="line">[root@test-monitor-farseer-1 ~]# ps aux | grep softirq</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         6  0.0  0.0      0     0 ?        S    Oct28  19:01 [ksoftirqd/0]</span><br><span class="line">root        14  0.0  0.0      0     0 ?        S    Oct28  18:35 [ksoftirqd/1]</span><br><span class="line">root        19  0.0  0.0      0     0 ?        S    Oct28   7:09 [ksoftirqd/2]</span><br><span class="line">root        24  0.0  0.0      0     0 ?        S    Oct28   7:10 [ksoftirqd/3]</span><br><span class="line">root     30245  0.0  0.0 112816   968 pts/0    S+   14:39   0:00 grep --color=auto softirq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 各种类型软中断在不同 CPU 上的累积运行次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TIMER（定时中断）、NET_RX（网络接收）、SCHED（内核调度）、RCU（RCU 锁）</span></span><br><span class="line">[root@test-monitor-farseer-1 ~]# cat /proc/softirqs</span><br><span class="line">                    CPU0       CPU1       CPU2       CPU3</span><br><span class="line">          HI:          0          0          1          0</span><br><span class="line">       TIMER:  292014081  279537013  269216764  281696252</span><br><span class="line">      NET_TX:       3831       3913       4199       4184</span><br><span class="line">      NET_RX:  618581709  594412079  267227921  266352263</span><br><span class="line">       BLOCK:   14715145          0          0          0</span><br><span class="line">BLOCK_IOPOLL:          0          0          0          0</span><br><span class="line">     TASKLET:       2443       2477       2541       2794</span><br><span class="line">       SCHED:   99688071   94729309   93448448  103069610</span><br><span class="line">     HRTIMER:          0          0          0          0</span><br><span class="line">         RCU:   78026892   73588176   68355387   69822162</span><br></pre></td></tr></table></figure>

<h1 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h1><p>CPU缓存是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU的运算速度要比内存读写速度快很多，这样会使CPU需要等待数据的到来或把数据写入到内存中。<br>高速缓存控制器是针对数据块，而不是字节进行操作的。高速缓存其实就是一组称之为缓存行(Cache Line)的固定大小的数据块组成的，典型的一行是64字节。</p>
<h2 id="CPU缓存的意义"><a href="#CPU缓存的意义" class="headerlink" title="CPU缓存的意义"></a>CPU缓存的意义</h2><p>CPU往往需要重复处理相同的数据、重复执行相同的指令，如果这部分数据、指令能在CPU缓存中找到，CPU就不需要从内存或硬盘中再读取数据、指令，从而减少了整机的响应时间。<br>CPU缓存的意义满足以下两种局部性原理：</p>
<ul>
<li>时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</li>
<li>空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</li>
</ul>
<p>就像数据库缓存一样，获取数据时首先会在最快的缓存中找数据，如果缓存没有命中(Cache miss) 则往下一级找, 直到三级缓存都找不到时，那只有向内存要数据了。一次次地未命中，代表取数据消耗的时间越长。</p>
<p><img src="/images/cpu/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%A4%9A%E6%A0%B8%E6%9C%BA%E5%99%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="高速缓存多核机器的存储结构"></p>
<p><img src="/images/cpu/IntelCorei5.png" alt="IntelCorei5"></p>
<h2 id="带有高速缓存CPU执行计算的流程"><a href="#带有高速缓存CPU执行计算的流程" class="headerlink" title="带有高速缓存CPU执行计算的流程"></a>带有高速缓存CPU执行计算的流程</h2><ul>
<li>程序以及数据被加载到主内存</li>
<li>指令和数据被加载到CPU的高速缓存</li>
<li>CPU执行指令，把结果写到高速缓存</li>
<li>高速缓存中的数据写回主内存</li>
</ul>
<p><img src="/images/cpu/CPU%E6%89%A7%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="CPU执行计算的流程"></p>
<h2 id="CPU缓存一致性协议-MESI"><a href="#CPU缓存一致性协议-MESI" class="headerlink" title="CPU缓存一致性协议-MESI"></a>CPU缓存一致性协议-MESI</h2><p>MESI为了保证多个CPU缓存中共享数据的一致性，为缓存行(Cache Line)定义了四种状态，而CPU对缓存行的四种操作可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候，需要对地址一致的缓存行的状态进行一致性修改，从而保证数据在多个缓存之间保持一致性。</p>
<h3 id="MESI状态"><a href="#MESI状态" class="headerlink" title="MESI状态"></a>MESI状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
<th>监听任务</th>
<th>状态转换</th>
</tr>
</thead>
<tbody><tr>
<td>M 修改 (Modified)</td>
<td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中</td>
<td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行</td>
<td>当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E 独享、互斥 (Exclusive)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中</td>
<td>缓存行必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td>
<td>当CPU修改该缓存行中内容时，该状态可以变成Modified状态</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>S 共享 (Shared)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中</td>
<td>缓存行必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）</td>
<td>当有一个CPU修改该缓存行时，其它CPU中该缓存行可以被作废（变成无效状态 Invalid）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>I 无效 (Invalid)</td>
<td>该Cache line无效。</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<p><img src="/images/cpu/cpu%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.png" alt="cpu多级缓存架构"></p>
<h3 id="多核缓存协同操作"><a href="#多核缓存协同操作" class="headerlink" title="多核缓存协同操作"></a>多核缓存协同操作</h3><p>内存变量</p>
<p><img src="/images/cpu/1.png" alt="内存变量"></p>
<p>单核读取</p>
<p><img src="/images/cpu/2.png" alt="单核读取"></p>
<p>双核读取</p>
<p><img src="/images/cpu/3.png" alt="双核读取"></p>
<p>修改数据</p>
<p><img src="/images/cpu/4.png" alt="修改数据"></p>
<p>同步数据</p>
<p><img src="/images/cpu/5.png" alt="同步数据"></p>
<h3 id="CPU-存储模型简介"><a href="#CPU-存储模型简介" class="headerlink" title="CPU 存储模型简介"></a>CPU 存储模型简介</h3><p>MESI协议为了保证多个 CPU cache 中共享数据的一致性，定义了 Cache line 的四种状态，而 CPU 对 cache 的4种操作可能会产生不一致状态，因此 cache 控制器监听到本地操作和远程操作的时候，需要对地址一致的 Cache line 状态做出一定的修改，从而保证数据在多个cache之间流转的一致性。</p>
<p>但是，缓存的一致性消息传递是要时间的，这就使得状态切换会有更多的延迟。某些状态的切换需要特殊的处理，可能会阻塞处理器。这些都将会导致各种各样的稳定性和性能问题。比如你需要修改本地缓存中的一条信息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。因为这个等待远远比一个指令的执行时间长的多。所以，为了为了避免这种阻塞导致时间的浪费，引入了存储缓存(Store Buffer)和无效队列(Invalidate Queue)。</p>
<!-- 
### 存储缓存

在没有存储缓存时，CPU 要写入一个量，有以下情况：

- 量不在该 CPU 缓存中，则需要发送 Read Invalidate 信号，再等待此信号返回，之后再写入量到缓存中。
- 量在该 CPU 缓存中，如果该量的状态是 Exclusive 则直接更改。而如果是 Shared 则需要发送 Invalidate 消息让其它 CPU 感知到这一更改后再更改。

这些情况中，很有可能会触发该 CPU 与其它 CPU 进行通讯，接着需要等待它们回复。这会浪费大量的时钟周期！为了提高效率，可以使用异步的方式去处理：先将值写入到一个 Buffer 中，再发送通讯的信号，等到信号被响应，再应用到 cache 中。并且此 Buffer 能够接受该 CPU 读值。这个 Buffer 就是 Store Buffer。而不须要等待对某个量的赋值指令的完成才继续执行下一条指令，直接去 Store Buffer 中读该量的值，这种优化叫Store Forwarding。

### 无效队列

同理，解决了主动发送信号端的效率问题，那么，接受端 CPU 接受到 Invalidate 信号后如果立即采取相应行动(去其它 CPU 同步值)，再返回响应信号，则时钟周期也太长了，此处也可优化。接受端 CPU 接受到信号后不是立即采取行动，而是将 Invalidate 信号插入到一个队列 Queue 中，立即作出响应。等到合适的时机，再去处理这个 Queue 中的 Invalidate 信号，并作相应处理。这个 Queue 就是Invalidate Queue。 -->


<p><img src="/images/cpu/%E6%A0%B9%E6%8D%AE%E6%8C%87%E6%A0%87%E6%89%BE%E5%B7%A5%E5%85%B7.png" alt="根据指标找工具"><br><img src="/images/cpu/%E9%80%9A%E8%BF%87%E5%B7%A5%E5%85%B7%E6%9F%A5%E6%8C%87%E6%A0%87.png" alt="通过工具查指标"><br><img src="/images/cpu/CPU%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90.png" alt="CPU性能优化分析"><br><img src="/images/cpu/linux%E6%80%A7%E8%83%BD%E5%9B%BE%E8%B0%B1.png" alt="Linux性能图谱"></p>
<!-- false sharing -->]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>io分析</title>
    <url>/2020/12/09/io%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h1><p>文件系统本身是对存储设备上的文件进行组织管理的机制。组织方式不同就形成不同的文件系统。<br>在Linux中一切皆为文件，为了方便管理Linux文件系统为每个文件都分配两个数据结构，索引节点、和目录项。</p>
<ul>
<li>索引节点 用来记录文件的元数据如inode编号、文件大小、访问权限等，inode跟文件内容一样都会被持久化到磁盘中</li>
<li>目录项 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。</li>
</ul>
<a id="more"></a>

<p><img src="/images/io%E5%88%86%E6%9E%90/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%85%B3%E7%B3%BB.png" alt="文件目录索引节点文件数据关系"></p>
<p>磁盘在执行文件系统格式化的时候会被划分成三个存储区域：</p>
<ul>
<li>超级块 存储整个文件系统的状态</li>
<li>索引节点区 用来存储索引节点</li>
<li>数据块区 则用来存储文件数据</li>
</ul>
<p>Linux为了支持不同的文件系统，内核在用户进程和文件系统的中间引入了一个抽象层，VFS。<br>VFS定义了一组所有文件系统都支持的数据结构和标准接口。</p>
<p><img src="/images/io%E5%88%86%E6%9E%90/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AD%98%E5%82%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="文件系统和存储的关系"></p>
<p>文件读写方式的各种差异导致I/O的分类多种多样。缓冲与非缓冲I/O、直接与非直接I/O、阻塞和非阻塞I/O、同步与异步I/O等。</p>
<ul>
<li><p>缓冲I/O 利用标准库缓存来加速文件的访问</p>
</li>
<li><p>非缓冲I/O 直接通过系统调用来访问文件，不再经过标准库缓存</p>
</li>
<li><p>直接I/O 跳过操作系统的页缓存，直接跟文件系统交互访问文件</p>
</li>
<li><p>非直接I/O 经过系统的页缓存，然后有内核或者系统调用真正写入磁盘</p>
</li>
<li><p>阻塞I/O 应用程序执行I/O操作后没有获得响应就会阻塞当前线程</p>
</li>
<li><p>非阻塞I/O 应用程序执行I/O操作后不会阻塞当前线程，执行其它任务，随后通过轮询或者事件通知的形式获得调用结果</p>
</li>
<li><p>同步I/O 程序执行I/O操作之后，要一直等到整个I/O完成后才能获得I/O响应</p>
</li>
<li><p>异步I/O 程序执行I/O操作之后，不用等待完成和完成后的响应，而是继续执行。等到这次I/O完成后，响应会用事件通知的方式告知应用程序</p>
</li>
</ul>
<h1 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h1><p>在Linux中磁盘实际上是作为一个块设备来管理的，也就是以块为单位读写数据，并且支持随机读写。每个块设备都会被赋予两个设备号，<br>分别是主、次设备号。主设备号主要用于驱动程序中，用来区分设备类型；而次设备号则是用来给多个同类设备编号</p>
<h2 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h2><p>和VFS类似，为了减少不同设备的差异带来的影响，Linux通过一个统一的通用块层来管理不同的设备。其实就是处在文件系统和磁盘中间的一个块设备抽象层，主要有以下两个功能：</p>
<ul>
<li>向上为文件系统和应用程序提供访问块的标准接口，向下把哥哥异构的磁盘设备统一抽象，并提供统一框架来管理这些设备的驱动程序</li>
<li>给文件系统和应用程序发来的I/O请求排队，并通过重新排序、请求、合并等方式提高磁盘读写效率</li>
</ul>
<h2 id="Linux四种I-O调度算法"><a href="#Linux四种I-O调度算法" class="headerlink" title="Linux四种I/O调度算法"></a>Linux四种I/O调度算法</h2><ul>
<li>NONE NONE确切等说不算调度算法，因为它完全不实用任何I/O调度器，对文件系统和应用程序的I/O其实不做任何处理，常在虚拟机中（此时磁盘I/O调度完全由物理机负责）</li>
<li>NOOP NOOP最简单的一种I/O调度算法，实际上是一个先入先出的队列，只做一些最基本的请求合并，常用于SSD磁盘</li>
<li>CFQ（Completely Fair Scheduler），被称为完全公平调度器，是现在很多发行版的默认 I/O 调度器，它为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求</li>
<li>DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）的请求被优先处理。DeadLine 调度算法，多用在 I/O 压力比较重的场景，比如数据库等</li>
</ul>
<h2 id="总结I-O栈"><a href="#总结I-O栈" class="headerlink" title="总结I/O栈"></a>总结I/O栈</h2><p>把 Linux 存储系统的 I/O 栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。 </p>
<ul>
<li>文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘数据</li>
<li>通用块层，包括块设备 I/O 队列和 I/O 调度器。它会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层</li>
<li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作</li>
</ul>
<h2 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h2><p>五个常见指标，使用率、饱和度、IOPS、吞吐量以及响应时间等。这五个指标，是衡量磁盘性能的基本指标。</p>
<ul>
<li>使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈</li>
<li>饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求</li>
<li>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数</li>
<li>吞吐量，是指每秒的 I/O 请求大小</li>
<li>响应时间，是指 I/O 请求从发出到收到响应的间隔时间</li>
</ul>
<p><img src="/images/io%E5%88%86%E6%9E%90/iostat%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E8%A7%A3%E8%AF%BB.png" alt="iostat性能指标解读"></p>
<h2 id="分析磁盘I-O瓶颈过程"><a href="#分析磁盘I-O瓶颈过程" class="headerlink" title="分析磁盘I/O瓶颈过程"></a>分析磁盘I/O瓶颈过程</h2><ol>
<li>先用 iostat 发现磁盘 I/O 性能瓶颈</li>
<li>再借助 pidstat ，定位出导致瓶颈的进程</li>
<li>随后分析进程的 I/O 行为</li>
<li>最后，结合应用程序的原理，分析这些 I/O 的来源</li>
</ol>
<p><img src="/images/io%E5%88%86%E6%9E%90/%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%B7%A5%E5%85%B7.png" alt="分析过程以及工具"></p>
<h2 id="I-O性能优化思路"><a href="#I-O性能优化思路" class="headerlink" title="I/O性能优化思路"></a>I/O性能优化思路</h2><h3 id="应用程序优化"><a href="#应用程序优化" class="headerlink" title="应用程序优化"></a>应用程序优化</h3><p>应用程序处于整个I/O栈的最上端，它可以通过系统调用来觉得I/O模式，同时它也是I/O数据的最终来源，在上帝视角中可以根据以下几个点来进行优化</p>
<ol>
<li>可以用追加写代替随机写，减少寻址开销，加快I/O写的速度</li>
<li>可以借助缓存I/O，充分利用系统缓存，降低实际I/O的次数</li>
<li>可以在应用程序内部构建自己的缓存，或者用 Redis 这类外部缓存系统。这样，一方面，能在应用程序内部，控制缓存的数据和生命周期；另一方面，也能降低其他应用程序使用缓存对自身的影响</li>
<li>在需要频繁读写同一块磁盘空间时，可以用mmap代替read/write，减少内存的拷贝次数</li>
<li>在需要同步写的场景中，尽量将写请求合并，而不是让每个请求都同步写入磁盘，即可以用fsync()取代O_SYNC</li>
<li>在多个应用程序共享相同磁盘时，为了保证I/O不被某个应用完全占用，推荐你使用cgroups的I/O子系统，来限制进程/进程组的IOPS以及吞吐量</li>
<li>在使用CFQ调度器时，可以用ionice来调整进程的I/O调度优先级，特别是提高核心应用的I/O优先级。ionice支持三个优先级类：Idle、Best-effort和Realtime。其中，Best-effort和Realtime 还分别支持0-7的级别，数值越小，则表示优先级别越高</li>
</ol>
<h3 id="文件系统优化"><a href="#文件系统优化" class="headerlink" title="文件系统优化"></a>文件系统优化</h3><h3 id="磁盘优化"><a href="#磁盘优化" class="headerlink" title="磁盘优化"></a>磁盘优化</h3><h1 id="网络I-O"><a href="#网络I-O" class="headerlink" title="网络I/O"></a>网络I/O</h1>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程小知识</title>
    <url>/2020/07/20/%E8%BF%9B%E7%A8%8B%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>进程就是应用程序启动的实例。进程拥有代码和打开的文件资源、数据资源、独立的内存空间</p>
<h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p>线程从属进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的自线程，线程拥有自己的栈空间。</p>
<ul>
<li>对操作系统来说线程是最小的执行单元，而进程是最小的资源管理单元。</li>
<li>无论线程还是进程都是操作系统管理的 </li>
</ul>
<a id="more"></a>

<h4 id="线程和进程的痛点"><a href="#线程和进程的痛点" class="headerlink" title="线程和进程的痛点"></a>线程和进程的痛点</h4><h4 id="从占用空间以及CPU利用率分析"><a href="#从占用空间以及CPU利用率分析" class="headerlink" title="从占用空间以及CPU利用率分析"></a>从占用空间以及CPU利用率分析</h4><p>进程在生命周期开始系统就会分配堆栈段和数据段，所以每个进程都会有独立的地址空间。<br>线程在创建后拥有独立的堆栈空间，但是会共享数据段。且线程之间使用相同的地址空间，共享大部分数据，相对进程较为节省，由此看出线程体积小，开销小，切换方便，cpu的利用率自然就大大提升了。</p>
<h4 id="从安全和复杂的角度分析"><a href="#从安全和复杂的角度分析" class="headerlink" title="从安全和复杂的角度分析"></a>从安全和复杂的角度分析</h4><p>进程之间相互独立，独立的地址空间使得进程之间相对很安全，一个进程崩溃并不会影响其他进程。然而进程之间的通信就比较复杂了，需要通过管道、信号量、消息队列、共享内存或者套接字的的机制。那么线程呢？由于使用相同的地址空间，使得线程并不安全，当一个线程崩溃时，必然会影响其他线程，使得整个进程崩溃。然而由于使用相同的地址空间等共享机制，使得线程之间的通信变得很方便。</p>
<h4 id="什么时候使用进程和线程"><a href="#什么时候使用进程和线程" class="headerlink" title="什么时候使用进程和线程"></a>什么时候使用进程和线程</h4><ol>
<li>当频繁创建和销毁的时候使用线程，创建进程的代价远高于线程</li>
<li>考虑安全性的时候使用进程</li>
<li>提高CPU利用率使用线程，即多核分布。多机分布用进程</li>
<li>并行操作时用线程</li>
<li>需要频繁切换，且大量计算时使用线程，同时耗时的计算操作使用线程可以提高程序的响应速度</li>
</ol>
<h4 id="进程和线程的痛点"><a href="#进程和线程的痛点" class="headerlink" title="进程和线程的痛点"></a>进程和线程的痛点</h4><ol>
<li>涉及到同步锁</li>
<li>涉及到线程阻塞和可运行状态之间的切换</li>
<li>涉及到线程上下文切换<br>以上任何一点都可能非常消耗性能</li>
</ol>
<h4 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h4><p>对于进程、线程都是内核进行调度，有CPU时间片的概念，进行抢占式调度。协程又称为微线程（Coroutine），类似子程序，如果A调用了子程序B，子程序B调用了子程序C，当程序C结束了返回子程序B继续执行之后的逻辑，当子程序B结束返回程序A，直到A运行结束。但是和子程序相比，协程又有刮起的概念，协程可以挂起跳转执行其他协程，合适的时机再跳转回来。<br>协程，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。更重要的是，协程不是被操作系统内核所管理的，而是完全有程序控制（用户态执行）。这样带来的好处是不会由于切换线程那样消耗性能，从而来保证性能的提升。</p>
<h4 id="线程调度原理"><a href="#线程调度原理" class="headerlink" title="线程调度原理"></a>线程调度原理</h4><p>N:1模型，多个用户空间线程在一个内核空间上运行。优势是上下文切换非常快，因为这些线程都在内核态运行，但是无法利用多核系统的有点。<br>1:1模型，1个内核空间线程运行一个用户空间。这种充分利用了多核系统的优势，但是上下文切换非常慢，因为每一次调度都会在用户态和内核态之间切换。POSIX线程模型（pthread）就是这么做的。<br>M:N模型，内核空间开启多个内核线程，一个内核空间线程对应多个用户空间线程。效率非常高，但是管理复杂。</p>
<h4 id="goroutine调度原理"><a href="#goroutine调度原理" class="headerlink" title="goroutine调度原理"></a>goroutine调度原理</h4><p>本质上goroutine就是协程，但是完全运行在用户动态，借鉴了M:N模型。M-P-G模型。</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E6%9D%82%E8%B0%88/goroutine.png" alt="WechatIMG8"></p>
<p>相比其他语言，go采用了MPG模型管理协程，更加高效，但是管理较为复杂。<br>M: 内核线程<br>G: 代表一个goroutine<br>P: Processor，处理器，用来管理和执行gorutine的</p>
<h4 id="G-M-P三者之间关系和特点"><a href="#G-M-P三者之间关系和特点" class="headerlink" title="G-M-P三者之间关系和特点"></a>G-M-P三者之间关系和特点</h4><p>P的个数取决于GOMAXPROCS，go新版本默认使用最大内核数。<br>M的数量和P不一定匹配，可以设置很多M，M和P绑定后才可以运行，多余的M处于休眠状态。<br>P包含一个LRQ（Local Run Queue）本地运行队列，里面保存着P需要执行的协程G的队列。<br>除了每个P自身保存的G的队列外，调度器还拥有一个全局的G队列（Global Run Queue），这个队列存储的是所有未分配的协程G。</p>
<h3 id="TCP相关"><a href="#TCP相关" class="headerlink" title="TCP相关"></a>TCP相关</h3><ul>
<li><p>控制堵塞针对的是发送端，堵塞控制是调节TCP连接上单次发送的分株数量的算法，通过增减单词发送量逐步调整，使之逼近当前网络的承载量。单次发送的分组数量就是堵塞窗口。</p>
</li>
<li><p>segment，发送端对滑动窗口内每个segment都设置了定时器，若有一个segment在规定的时间内没收到Ack，则认为当前网络又堵塞，执行快恢复。</p>
</li>
<li><p>滑动窗口的意义，可靠性，滑动窗口只有在队列前部的被确认之后，才会往后移动，保证数据包被接收方正确接收且确认。其次是传输效率，假如没有窗口，服务端是杂乱无章的进行发包，因为tcp是队首效应，如果前面的包没有发送成功，就会不停的重试，反而造成更差的传输效率。最后稳定性，tcp的滑动窗口大小是整个复杂网络商榷的结果，会进行动态调整，可以尽量避免网络拥塞，更加稳定。</p>
</li>
</ul>
<h4 id="水平触发"><a href="#水平触发" class="headerlink" title="水平触发"></a>水平触发</h4><p>如果文件描述符已经就绪可以非阻塞的执行IO操作了，此时会触发通知，允许在任意时刻重复检测IO的状态。select、poll就是属于水平触发。</p>
<h4 id="边缘触发"><a href="#边缘触发" class="headerlink" title="边缘触发"></a>边缘触发</h4><p>如果文件描述符自上次改变后有新的IO活动到来，此时才会触发通知，在收到一个IO通知事件后要尽量可能多的执行IO操作，因为如果在一次通知中没有执行完IO那么就要等到下次新的IO活动到来才能取到就绪的描述符号，信号驱动式属于边缘触发。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql小知识</title>
    <url>/2020/07/20/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="事务的基本要素"><a href="#事务的基本要素" class="headerlink" title="事务的基本要素"></a>事务的基本要素</h4><ul>
<li><p>原子性<br>  事务开始后的所有操作要么做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错会回滚到事务开始的状态。所有的操作就像没有发生过一样。也就是说一个事务是一个不可分割的整体。(undo log实现)</p>
</li>
<li><p>一致性<br>  事务开始前和结束后，数据库的完整约束没有被破坏。如A向B赚钱，不可能A扣了钱，B却没收到。</p>
</li>
<li><p>隔离性<br>  统一时间只允许一个事务请求同一数据，不同事务之间彼此没有任何干扰。比如A正从银行开中取钱，在A取钱的过程中，B不能向这张卡转账。</p>
</li>
<li><p>持久性<br>事务一旦提交，其更改是永久性的，即使数据库系统崩溃也能恢复。（redo log实现）</p>
<a id="more"></a>
<h4 id="redo-log也是需要在事物提交时将日志写入硬盘，为什么它比直接将Buffer-Pool中修改的数据写入硬盘（脏刷）要快？"><a href="#redo-log也是需要在事物提交时将日志写入硬盘，为什么它比直接将Buffer-Pool中修改的数据写入硬盘（脏刷）要快？" class="headerlink" title="redo log也是需要在事物提交时将日志写入硬盘，为什么它比直接将Buffer Pool中修改的数据写入硬盘（脏刷）要快？"></a>redo log也是需要在事物提交时将日志写入硬盘，为什么它比直接将Buffer Pool中修改的数据写入硬盘（脏刷）要快？</h4><ol>
<li>脏刷是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO</li>
<li>脏刷以数据页（Page）为单位，mysql默认页大小为16KB，一个Page上一个小修改都要整页写入；而redo log只包含真正需要写入的部分，无效IO大大减少</li>
</ol>
</li>
</ul>
<h4 id="redo-log与binlog"><a href="#redo-log与binlog" class="headerlink" title="redo log与binlog"></a>redo log与binlog</h4><pre><code>binlog(二进制日志)也可以用于记录操作并用于数据的恢复，其和redo log的区别如下</code></pre>
<ol>
<li>作用不同<br> redo log用于crash recovery，保证mysql宕机也不会影响持久性，而binlog用于point-in-time recovery，保证服务器可以基于时间点恢复数据，另外binlog还用于主从复制</li>
<li>层次不同<br> redo log是InnoDB存储引擎实现的，而binlog是mysql服务器层实现的</li>
<li>内容不同<br> redo log是物理日志，内容基于硬盘page；binlog的内容是二进制的，根据binlog_format参数不同，可能基于sql语句、基于数据本身或者二者的混合</li>
<li>写入时机不同<br> binlog在事物提交时写入；redo log的写入时机相当多元（可以根本配置策略不同改变写入时机）</li>
</ol>
<p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
<h4 id="Mysql创建索引需要遵守原则"><a href="#Mysql创建索引需要遵守原则" class="headerlink" title="Mysql创建索引需要遵守原则"></a>Mysql创建索引需要遵守原则</h4><ol>
<li><p>选择唯一性索引</p>
<p>值是唯一的，例如学生表中的学号</p>
</li>
<li><p>为经常需要排序、分组和联合操作的字段建立索引</p>
<p>经常需要order by、group by、distinct和union等操作的字段，排序操作费时。建立索引影后可以有效避免排序操作</p>
</li>
<li><p>为经常作为查询条件的字段建立索引</p>
<p>作为查询条件，为这样的字段建立索引可以提供整张表的查询速度</p>
</li>
<li><p>限制索引的数目</p>
<p>索引的数目不是越多越好，每个索引都占用硬盘空间，索引越多，需要的空间就越大。需改表时，对索引的重构和更新很麻烦。索引越多，更新表越费时</p>
</li>
<li><p>尽量使用数据少的索引</p>
<p>如果索引的值很长，那么查询的速度会受到影响</p>
</li>
<li><p>尽量使用前缀来索引</p>
<p>如果索引字段的值很长，最好使用值的前缀来索引</p>
</li>
<li><p>删除不再使用或很少使用的索引</p>
</li>
<li><p>最左匹配原则</p>
<p>Mysql会一直向右匹配，知道遇到范围查询（&lt;、&gt;、between、like）就停止匹配。如a = 1 and b = 2 and c &gt; 3 and d = 4，如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立（a,b,d,c）顺序的索引，则都可以用到，且a,b,d顺序可以任意调整。</p>
</li>
<li><p>=和in可以乱序</p>
<p>比如a = 1 and b = 2 and c = 3，建立（a,b,c）索引，a,b,c可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
</li>
<li><p>尽量选择区分度高的列作为索引</p>
<p>区分度计算公式: count(distinct(col))/count(*)，表示字段不重复的比例，比例越大，扫描的记录数据越少。</p>
</li>
<li><p>索引不能参与计算，保持“列干净”</p>
<p>比如from_unixtime （create_time） = ‘2020-07-08’ 就不能用到索引，因为B+树中存的是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，成本太大。语句应该写成create_time = unix_timestamp(‘2020-07-08’)</p>
</li>
<li><p>尽量的扩展索引，不要新建索引</p>
</li>
</ol>
]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>跨进程复制socket</title>
    <url>/2020/12/15/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E5%A4%8D%E5%88%B6socket/</url>
    <content><![CDATA[<h1 id="linux为什么能跨进程传递socket文件描述符"><a href="#linux为什么能跨进程传递socket文件描述符" class="headerlink" title="linux为什么能跨进程传递socket文件描述符"></a>linux为什么能跨进程传递socket文件描述符</h1><p>在Linux中一切皆文件，文件系统是进程所共有的。而socket本身是在网络文件系统空间申请的，socket也是文件一种，所以在同一台主机下，socket是可以跨进程传递的。<br>下面仔细跟踪一下socket创建的过程（3.10内核）。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sock_map_fd</span><span class="params">(struct socket *sock, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">    <span class="comment">// 分配fd</span></span><br><span class="line">	<span class="keyword">int</span> fd = get_unused_fd_flags(flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(fd &lt; <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">    <span class="comment">// 到网络空间分配文件</span></span><br><span class="line">	newfile = sock_alloc_file(sock, flags, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (likely(!IS_ERR(newfile))) &#123;</span><br><span class="line">		fd_install(fd, newfile);</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	put_unused_fd(fd);</span><br><span class="line">	<span class="keyword">return</span> PTR_ERR(newfile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络空间分配文件</span></span><br><span class="line"><span class="function">struct file *<span class="title">sock_alloc_file</span><span class="params">(struct socket *sock, <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">name</span> =</span> &#123; .name = <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dname) &#123;</span><br><span class="line">		name.name = dname;</span><br><span class="line">		name.len = <span class="built_in">strlen</span>(name.name);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;sk) &#123;</span><br><span class="line">		name.name = sock-&gt;sk-&gt;sk_prot_creator-&gt;name;</span><br><span class="line">		name.len = <span class="built_in">strlen</span>(name.name);</span><br><span class="line">	&#125;</span><br><span class="line">	path.dentry = d_alloc_pseudo(sock_mnt-&gt;mnt_sb, &amp;name);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!path.dentry))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	path.mnt = mntget(sock_mnt);</span><br><span class="line"></span><br><span class="line">	d_instantiate(path.dentry, SOCK_INODE(sock));</span><br><span class="line">	SOCK_INODE(sock)-&gt;i_fop = &amp;socket_file_ops;</span><br><span class="line"></span><br><span class="line">	file = alloc_file(&amp;path, FMODE_READ | FMODE_WRITE,</span><br><span class="line">		  &amp;socket_file_ops);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(IS_ERR(file))) &#123;</span><br><span class="line">		<span class="comment">/* drop dentry, keep inode */</span></span><br><span class="line">		ihold(path.dentry-&gt;d_inode);</span><br><span class="line">		path_put(&amp;path);</span><br><span class="line">		<span class="keyword">return</span> file;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 对于下面两行的拓展使用:</span></span><br><span class="line">    <span class="comment">// 系统在使用socket接口进行操作到时候，都需要通过这个文件来获取socket结构,那么只要有文件描述符，就可以在file结构中</span></span><br><span class="line">    <span class="comment">// private_data字段获取socket结构，并对其进行操作</span></span><br><span class="line">    <span class="comment">// 所以同一台主机上socket文件是可以传递的。</span></span><br><span class="line">	sock-&gt;file = file;</span><br><span class="line">	file-&gt;f_flags = O_RDWR | (flags &amp; O_NONBLOCK);</span><br><span class="line">	file-&gt;private_data = sock;</span><br><span class="line">	<span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="如何传递、传递过程中注意哪些问题"><a href="#如何传递、传递过程中注意哪些问题" class="headerlink" title="如何传递、传递过程中注意哪些问题"></a>如何传递、传递过程中注意哪些问题</h1><ul>
<li>父子进程建立unix socket连接传递</li>
<li>假设传递的socket为client_fd，调用dup_fd = dup(client_fd)（复制fd），然后将<br>sendmsg发送给子进程，然后close(client_fd)（在发往子进程网络的过程中，socket依然可以接收数据，这时候父进程可能捕获到该事件并读取了数据可能导致子进程<br>获取不到该事件，导致数据漏读，如果先dup一个出来，然后把原来的关闭，那么等dup_fd到达之后就可以响应到该数据事件），</li>
<li>子进程recvmsg收到dup_fd之后，调用new_fd = dup(dup_fd)，然后close(dup_fd)（原因同样是在传递过程中接收到数据，这样dup_fd没有办法捕捉到，dup之后就能获取到该数据响应事件）</li>
<li>DupCloseOnExec close_on_exec，当父进程打开文件时，只需要应用程序设置FD_CLOSEXEC标志位，则当fork后exec其他程序的时候，内核自动会将其继承的父进程FD关闭</li>
<li>unix socket也可以像其它fd一样进行跨进程复制</li>
<li>跨进程复制的listen fd如果不关闭，都可以accept</li>
<li>跨进程复制的socket如果不关闭，都可以进行收发数据，收数据的时候竞争关系</li>
<li>复制过去的socket接收、发送缓存区是同一个</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// socket发送、接收函数</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">const</span> struct msghdr *message, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> socket, struct msghdr *message, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>		*msg_name;	<span class="comment">/* ptr to socket address structure */</span> <span class="comment">// 数据的目的地址，网络包指向sockaddr_in, netlink则指向sockaddr_nl;</span></span><br><span class="line">	<span class="keyword">int</span>		msg_namelen;	<span class="comment">/* size of socket address structure */</span> <span class="comment">// msg_name 所代表的地址长度</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>	*<span class="title">msg_iov</span>;</span>	<span class="comment">/* scatter/gather array */</span>  <span class="comment">// 指向的是缓冲区数组</span></span><br><span class="line">	<span class="keyword">__kernel_size_t</span>	msg_iovlen;	<span class="comment">/* # elements in msg_iov */</span> <span class="comment">// 缓冲区数组长度</span></span><br><span class="line">	<span class="keyword">void</span>		*msg_control;	<span class="comment">/* ancillary data */</span>    <span class="comment">// 辅助数据，控制信息(发送任何的控制信息)</span></span><br><span class="line">	<span class="keyword">__kernel_size_t</span>	msg_controllen;	<span class="comment">/* ancillary data buffer length */</span>  <span class="comment">// 辅助信息长度</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_flags;	<span class="comment">/* flags on received message */</span> <span class="comment">// 消息标识</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">void</span> __user *iov_base;	<span class="comment">/* BSD uses caddr_t (1003.1g requires void *) */</span></span><br><span class="line">	<span class="keyword">__kernel_size_t</span> iov_len; <span class="comment">/* Must be size_t (1003.1g) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line">	<span class="keyword">__kernel_size_t</span>	cmsg_len;	<span class="comment">/* data byte count, including hdr */</span></span><br><span class="line">        <span class="keyword">int</span>		cmsg_level;	<span class="comment">/* originating protocol */</span></span><br><span class="line">        <span class="keyword">int</span>		cmsg_type;	<span class="comment">/* protocol-specific type */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的例子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcpServer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_fd</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iovec iov[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = &amp;c;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len  = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cmsgsize = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    cmsghdr* cmptr = (cmsghdr*)<span class="built_in">malloc</span>(cmsgsize);</span><br><span class="line">    <span class="keyword">if</span>(cmptr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[send_fd] init cmptr error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cmptr-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmptr-&gt;cmsg_type = SCM_RIGHTS; <span class="comment">// we are sending fd.</span></span><br><span class="line">    cmptr-&gt;cmsg_len = cmsgsize;</span><br><span class="line"> </span><br><span class="line">    msghdr msg;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">    msg.msg_control = cmptr;</span><br><span class="line">    msg.msg_controllen = cmsgsize;</span><br><span class="line">    *(<span class="keyword">int</span> *)CMSG_DATA(cmptr) = fd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = sendmsg(sock, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(cmptr);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[send_fd] sendmsg error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_fd</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cmsgsize = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    cmsghdr* cmptr = (cmsghdr*)<span class="built_in">malloc</span>(cmsgsize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>]; <span class="comment">// the max buf in msg.</span></span><br><span class="line">    iovec iov[<span class="number">1</span>];</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    </span><br><span class="line">    msghdr msg;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen  = <span class="number">1</span>;</span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">    msg.msg_control = cmptr;</span><br><span class="line">    msg.msg_controllen = cmsgsize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = recvmsg(sock, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// free(cmptr);</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[recv_fd] recvmsg error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fd = *(<span class="keyword">int</span> *)CMSG_DATA(cmptr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;接收的fd为&quot;</span>&lt;&lt; fd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int nfd = dup(fd);</span></span><br><span class="line">    <span class="comment">// return nfd;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_process_cycle</span><span class="params">(<span class="keyword">int</span> fds[<span class="number">2</span>])</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;master process #&quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// master use fds[0], and close fds[1]</span></span><br><span class="line">    <span class="keyword">int</span> fd = fds[<span class="number">0</span>];</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;channel: #&quot;</span> &lt;&lt; fds[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, #&quot;</span> &lt;&lt; fds[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;, fd=#&quot;</span> &lt;&lt; fd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenFD = tcpServer();</span><br><span class="line">    <span class="keyword">if</span> (listenFD &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;tcp server fail&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    send_fd(fd, listenFD);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// pause();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker_process_cycle</span><span class="params">(<span class="keyword">int</span> fds[<span class="number">2</span>])</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;worker process #&quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = fds[<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">int</span> file = recv_fd(fd);</span><br><span class="line">    <span class="keyword">if</span>(file &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[worker] invalid fd! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;current pid: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, fds) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;failed to create domain socket by socketpair&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create domain socket by socketpair success&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create progress to communicate over domain socket&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        worker_process_cycle(fds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        master_process_cycle(fds);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// pause();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">tcpServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenFD;</span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">socklen_t</span> addrLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, pid_child, pid_send;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((listenFD = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create socket err \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置服务端地址*/</span></span><br><span class="line">    addrLen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, addrLen);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*绑定地址结构到套接字描述符*/</span></span><br><span class="line">    <span class="keyword">if</span> (bind(listenFD, (struct sockaddr *) &amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind fail&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(listenFD, <span class="number">100</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;listen fail&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenFD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/socket/1.png" alt="Linux 使用率"></p>
<p>测试不两个进程同时拥有socket的测试代码，按需求自己打开注释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/sys/unix&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tcpSrv := NewTcpSrv()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := tcpSrv.Init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;tcp srv init fail, err is&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := tcpSrv.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;tcp srv start fail, err is&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//// 迁移listen</span></span><br><span class="line">		<span class="comment">//if err := tcpSrv.SendListenerWithUnixSocket(); err != nil &#123;</span></span><br><span class="line">		<span class="comment">//	fmt.Println(&quot;send listener with unix socket fail, err is&quot;, err)</span></span><br><span class="line">		<span class="comment">//	return</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 迁移conn</span></span><br><span class="line">		<span class="keyword">if</span> err := tcpSrv.SendConnWithUnixSocket(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;send listener with unix socket fail, err is&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//// 迁移listen</span></span><br><span class="line">		<span class="comment">//if err := tcpSrv.RecvListenerFromUnixSocket(); err != nil &#123;</span></span><br><span class="line">		<span class="comment">//	fmt.Println(&quot;recv listener with unix socket fail, err is&quot;, err)</span></span><br><span class="line">		<span class="comment">//	return</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 迁移conn</span></span><br><span class="line">		<span class="keyword">if</span> err := tcpSrv.RecvConnFromUnixSocket(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;recv listener with unix socket fail, err is&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TcpSrv <span class="keyword">struct</span> &#123;</span><br><span class="line">	listener *net.TCPListener</span><br><span class="line">	conns    <span class="keyword">map</span>[<span class="keyword">string</span>]*net.TCPConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTcpSrv</span><span class="params">()</span> *<span class="title">TcpSrv</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;TcpSrv&#123;</span><br><span class="line">		conns: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*net.TCPConn),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TcpSrv)</span> <span class="title">Init</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:7000&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t.listener = listener.(*net.TCPListener)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TcpSrv)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			conn, err := t.listener.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;accept fail, err msg is&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">go</span> t.clientSrv(conn)</span><br><span class="line">			storeConn := conn.(*net.TCPConn)</span><br><span class="line">			t.conns[conn.RemoteAddr().String()] = storeConn</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TcpSrv)</span> <span class="title">StartWithListenSocket</span><span class="params">(listener *net.TCPListener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			c, err := listener.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;accept fail, err msg is&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">go</span> t.clientSrv(c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TcpSrv)</span> <span class="title">clientSrv</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">		nRead, err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;read msg fail, err is&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;recv msg is&quot;</span>, <span class="keyword">string</span>(buf[:nRead]))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> _, err := conn.Write(buf[:nRead]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;write msg fail, err is&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TcpSrv)</span> <span class="title">SendListenerWithUnixSocket</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	_ = os.Remove(<span class="string">&quot;/tmp/unix_socket_tcp&quot;</span>)</span><br><span class="line">	addr, err := net.ResolveUnixAddr(<span class="string">&quot;unix&quot;</span>, <span class="string">&quot;/tmp/unix_socket_tcp&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Cannot resolve unix addr: &quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	listener, err := net.ListenUnix(<span class="string">&quot;unix&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Cannot listen to unix domain socket: &quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Listening on&quot;</span>, listener.Addr())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			c, err := listener.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;Accept: &quot;</span> + err.Error())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			file, _ := t.listener.File()</span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>)</span><br><span class="line">			buf[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">			rights := syscall.UnixRights(<span class="keyword">int</span>(file.Fd()))</span><br><span class="line">			_, _, err = c.(*net.UnixConn).WriteMsgUnix(buf, rights, <span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;同步listen socket fail, err is&quot;</span>, err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TcpSrv)</span> <span class="title">RecvListenerFromUnixSocket</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	connInterface, err := net.Dial(<span class="string">&quot;unix&quot;</span>, <span class="string">&quot;/tmp/unix_socket_tcp&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;net dial unix fail&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		_ = connInterface.Close()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	unixConn := connInterface.(*net.UnixConn)</span><br><span class="line"></span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>)</span><br><span class="line">	oob := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		err = unixConn.SetWriteDeadline(time.Now().Add(time.Minute * <span class="number">3</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		n, oobn, _, _, err := unixConn.ReadMsgUnix(b, oob)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n != <span class="number">1</span> || b[<span class="number">0</span>] != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> n != <span class="number">1</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;recv fd type error: %d\n&quot;</span>, n)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;init finish&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		scms, err := unix.ParseSocketControlMessage(oob[<span class="number">0</span>:oobn])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(scms) != <span class="number">1</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;recv fd num != 1 : %d\n&quot;</span>, <span class="built_in">len</span>(scms))</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		fds, err := unix.ParseUnixRights(&amp;scms[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(fds) != <span class="number">1</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;recv fd num != 1 : %d\n&quot;</span>, <span class="built_in">len</span>(fds))</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;recv fd %d\n&quot;</span>, fds[<span class="number">0</span>])</span><br><span class="line">		<span class="comment">// 这里需要把file close， 不然每次重启都会多复制一个socket</span></span><br><span class="line">		file := os.NewFile(<span class="keyword">uintptr</span>(fds[<span class="number">0</span>]), <span class="string">&quot;fd-from-old&quot;</span>)</span><br><span class="line">		conn, err := net.FileListener(file)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		_ = file.Close()</span><br><span class="line">		fmt.Println(conn)</span><br><span class="line"></span><br><span class="line">		lc := conn.(*net.TCPListener)</span><br><span class="line">		<span class="keyword">go</span> t.StartWithListenSocket(lc)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TcpSrv)</span> <span class="title">SendConnWithUnixSocket</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	_ = os.Remove(<span class="string">&quot;/tmp/unix_socket_tcp&quot;</span>)</span><br><span class="line">	addr, err := net.ResolveUnixAddr(<span class="string">&quot;unix&quot;</span>, <span class="string">&quot;/tmp/unix_socket_tcp&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Cannot resolve unix addr: &quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	listener, err := net.ListenUnix(<span class="string">&quot;unix&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Cannot listen to unix domain socket: &quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Listening on&quot;</span>, listener.Addr())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			c, err := listener.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;Accept: &quot;</span> + err.Error())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, conn := <span class="keyword">range</span> t.conns &#123;</span><br><span class="line">				file, _ := conn.File()</span><br><span class="line">				buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>)</span><br><span class="line">				buf[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">				rights := syscall.UnixRights(<span class="keyword">int</span>(file.Fd()))</span><br><span class="line">				_, _, err = c.(*net.UnixConn).WriteMsgUnix(buf, rights, <span class="literal">nil</span>)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Println(<span class="string">&quot;同步listen socket fail, err is&quot;</span>, err.Error())</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TcpSrv)</span> <span class="title">RecvConnFromUnixSocket</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	connInterface, err := net.Dial(<span class="string">&quot;unix&quot;</span>, <span class="string">&quot;/tmp/unix_socket_tcp&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;net dial unix fail&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		_ = connInterface.Close()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	unixConn := connInterface.(*net.UnixConn)</span><br><span class="line"></span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>)</span><br><span class="line">	oob := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		err = unixConn.SetWriteDeadline(time.Now().Add(time.Minute * <span class="number">3</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		n, oobn, _, _, err := unixConn.ReadMsgUnix(b, oob)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n != <span class="number">1</span> || b[<span class="number">0</span>] != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> n != <span class="number">1</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;recv fd type error: %d\n&quot;</span>, n)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;init finish&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		scms, err := unix.ParseSocketControlMessage(oob[<span class="number">0</span>:oobn])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(scms) != <span class="number">1</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;recv fd num != 1 : %d\n&quot;</span>, <span class="built_in">len</span>(scms))</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		fds, err := unix.ParseUnixRights(&amp;scms[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(fds) != <span class="number">1</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;recv fd num != 1 : %d\n&quot;</span>, <span class="built_in">len</span>(fds))</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;recv fd %d\n&quot;</span>, fds[<span class="number">0</span>])</span><br><span class="line">		<span class="comment">// 这里需要把file close， 不然每次重启都会多复制一个socket</span></span><br><span class="line">		file := os.NewFile(<span class="keyword">uintptr</span>(fds[<span class="number">0</span>]), <span class="string">&quot;fd-from-old&quot;</span>)</span><br><span class="line">		conn, err := net.FileConn(file)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		_ = file.Close()</span><br><span class="line">		fmt.Println(conn)</span><br><span class="line">		t.clientSrv(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
